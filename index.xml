<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>lin</title>
        <link>https://oslinss.github.io/</link>
        <description>Recent content on lin</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>en</language>
        <copyright>lin</copyright>
        <lastBuildDate>Sun, 06 Apr 2025 13:38:53 +0800</lastBuildDate><atom:link href="https://oslinss.github.io/index.xml" rel="self" type="application/rss+xml" /><item>
        <title>算法</title>
        <link>https://oslinss.github.io/p/%E7%AE%97%E6%B3%95/</link>
        <pubDate>Sun, 06 Apr 2025 13:38:53 +0800</pubDate>
        
        <guid>https://oslinss.github.io/p/%E7%AE%97%E6%B3%95/</guid>
        <description>&lt;h1 id=&#34;算法笔记&#34;&gt;算法笔记
&lt;/h1&gt;&lt;h1 id=&#34;1-算法基础&#34;&gt;1 算法基础
&lt;/h1&gt;&lt;h2 id=&#34;11-二分查找&#34;&gt;1.1 二分查找
&lt;/h2&gt;&lt;p&gt;二分查找是一种算法，其输入是一个有序的元素列表，对于包含n个元素的列表。
用二分查找最多需要log2n步，而简单查找最多需要n步。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;def binary_search(list, item): 
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    low = 0 
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    high = len(list)-1 
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    while low &amp;lt;= high:
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        mid = (low + high)
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        guess = list[mid] 
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        if guess == item:
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            return mid 
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        if guess &amp;gt; item:
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            high = mid - 1 
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        else:
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            low = mid + 1 
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            return None 
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;my_list = [1, 3, 5, 7, 9] 
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;print(binary_search(my_list, 3)) 
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;print(binary_search(my_list, -1)) 
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h2 id=&#34;12-大o表示法&#34;&gt;1.2 大O表示法
&lt;/h2&gt;&lt;p&gt;大O表示法是一种特殊的表示法，指出了算法的速度有多快。&lt;/p&gt;
&lt;h3 id=&#34;121-算法的运行时间以不同的速度增加&#34;&gt;1.2.1 算法的运行时间以不同的速度增加
&lt;/h3&gt;&lt;p&gt;&lt;img src=&#34;https://oslinss.github.io/b0916f3c-f78a-4107-d82d-a7c9843c4f5f-1.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;alt text&#34;
	
	
&gt;
&lt;img src=&#34;https://oslinss.github.io/2bb365d3-efed-4a83-dc39-6baf00d9eee3-2-1.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;alt text&#34;
	
	
&gt;&lt;/p&gt;
&lt;h3 id=&#34;122-一些常见的大o的运行时间&#34;&gt;1.2.2 一些常见的大O的运行时间
&lt;/h3&gt;&lt;p&gt;O(log n)，也叫对数时间，这样的算法包括二分查找。
O(n)，也叫线性时间，这样的算法包括简单查找。
O(n * log n)，这样的算法包括第4章将介绍的快速排序——一种速度较快的排序算法。
O(n2)，这样的算法包括第2章将介绍的选择排序——一种速度较慢的排序算法。
O(n!)，这样的算法包括接下来将介绍的旅行商问题的解决方案——一种非常慢的算法。&lt;br&gt;
算法的速度指的并非时间，而是操作数的增速。
算法运行时间并不以秒为单位。
算法运行时间是从其增速的角度度量的。
算法的运行时间用大O表示法表示。O(log n)比O(n)快，当需要搜索的元素越多时，前者比后者快得越多。&lt;/p&gt;
&lt;h1 id=&#34;2-选择排序&#34;&gt;2 选择排序
&lt;/h1&gt;&lt;h1 id=&#34;21-内存的工作原理&#34;&gt;2.1 内存的工作原理
&lt;/h1&gt;&lt;p&gt;需要将数据存储到内存时，你请求计算机提供存储空间，计算机给你一个存储地址。需要存储多项数据时，有两种基本方式——数组和链表。&lt;/p&gt;
&lt;h2 id=&#34;22-数组和链表&#34;&gt;2.2 数组和链表
&lt;/h2&gt;&lt;p&gt;数组的元素都在一起。
链表的元素是分开的，其中每个元素都存储了下一个元素的地址。
数组的读取速度很快。
链表的插入和删除速度很快。
在同一个数组中，所有元素的类型都必须相同（都为int、double等）。
有两种访问方式：随机访问和顺序访问。
顺序访问意味着从第一个元素开始逐个地读取元素。链表只能顺序访问
&lt;img src=&#34;https://oslinss.github.io/82e92ba1-01e9-4853-9c06-581ba3fd7bca-1.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;alt text&#34;
	
	
&gt;&lt;/p&gt;
&lt;h2 id=&#34;23-选择排序&#34;&gt;2.3 选择排序
&lt;/h2&gt;&lt;p&gt;随着排序的进行，每次需要检查的元素数在逐渐减少，最后一次需要检查的元素都只有一个。
需要的总时间为 O(n × n)，即O(n^2)。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;def findSmallest(arr): 
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    smallest = arr[0]
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    smallest_index = 0 
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    for i in range(1, len(arr)): 
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        if arr[i] &amp;lt; smallest: 
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            smallest = arr[i] 
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            smallest_index = i 
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    return smallest_index 
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;def selectionSort(arr):
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    newArr = [] 
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    for i in range(len(arr)): 
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        smallest = findSmallest(arr)
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        newArr.append(arr.pop(smallest)) 
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    return newArr 
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;print(selectionSort([5, 3, 6, 2, 10]))
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h1 id=&#34;3-递归&#34;&gt;3 递归
&lt;/h1&gt;&lt;p&gt;递归——函数调用自己&lt;/p&gt;
&lt;h2 id=&#34;31-基线条件和递归条件&#34;&gt;3.1 基线条件和递归条件
&lt;/h2&gt;&lt;p&gt;每个递归函数都有两部分：基线条件（base case）和递归条件（recursive case）。
递归条件指的是函数调用自己，而基线条件则指的是函数不再调用自己，从而避免形成无限循环。&lt;/p&gt;
&lt;h2 id=&#34;32-栈&#34;&gt;3.2 栈
&lt;/h2&gt;&lt;p&gt;栈有两种操作：压入和弹出。&lt;/p&gt;
&lt;h3 id=&#34;321-调用栈&#34;&gt;3.2.1 调用栈
&lt;/h3&gt;&lt;p&gt;这个栈用于存储多个函数的变量，被称为调用栈。
所有函数调用都进入调用栈。
调用另一个函数时，当前函数暂停并处于未完成状态。该函数的所有变量的值都还在内存中。
调用栈可能很长，这将占用大量的内存。&lt;/p&gt;
&lt;h3 id=&#34;322-递归调用栈&#34;&gt;3.2.2 递归调用栈
&lt;/h3&gt;&lt;p&gt;&lt;img src=&#34;https://oslinss.github.io/13cb2a0e-4cbf-4cce-8c89-daefa4d789ea-1.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;alt text&#34;
	
	
&gt;
&lt;img src=&#34;https://oslinss.github.io/8e4608ae-48b7-42ca-f946-d6f5fdc04dc6-1.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;alt text&#34;
	
	
&gt;
&lt;img src=&#34;https://oslinss.github.io/8a0ab4eb-1adc-4c02-ecfc-cfc56950ce81-1.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;alt text&#34;
	
	
&gt;
&lt;img src=&#34;https://oslinss.github.io/5b029480-f68d-4db5-a000-55e70ff38c93-1.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;alt text&#34;
	
	
&gt;
&lt;img src=&#34;https://oslinss.github.io/1397cf89-9a0a-4973-f9a0-858ba6fdb72e-1.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;alt text&#34;
	
	
&gt;
&lt;img src=&#34;https://oslinss.github.io/4308e556-8bc8-4fa9-f3af-ebde46067d7f-1.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;alt text&#34;
	
	
&gt;
每个fact调用都有自己的x变量。在一个函数调用中不能访问另一个的x变量。&lt;/p&gt;
&lt;h1 id=&#34;4-快速排序&#34;&gt;4 快速排序
&lt;/h1&gt;&lt;h2 id=&#34;41-分而治之&#34;&gt;4.1 分而治之
&lt;/h2&gt;&lt;p&gt;使用D&amp;amp;C解决问题的过程包括两个步骤。
(1) 找出基线条件，这种条件必须尽可能简单。（最容易处理的情况是，一条边的长度是另一条边的整数倍。）
(2) 不断将问题分解（或者说缩小规模），直到符合基线条件。&lt;br&gt;
使用递归函数完成
（1）找出基线条件
（2）每次递归调用都必须离空数组更近一步&lt;/p&gt;
&lt;h2 id=&#34;42-快速排序&#34;&gt;4.2 快速排序
&lt;/h2&gt;&lt;p&gt;快速排序也使用了D&amp;amp;C
基线条件为数组为空或只包含一个元素。
从数组中选择一个元素，这个元素被称为基准值（pivot）。
(1) 选择基准值。
(2) 将数组分成两个子数组：小于基准值的元素和大于基准值的元素。
(3) 对这两个子数组进行快速排序。&lt;/p&gt;
&lt;h2 id=&#34;43-平均情况和最糟情况&#34;&gt;4.3 平均情况和最糟情况
&lt;/h2&gt;&lt;p&gt;在最糟情况下，栈长为O(n)，而在最佳情况下，栈长为O(log n)。&lt;/p&gt;
&lt;h1 id=&#34;5-散列表无序&#34;&gt;5 散列表(无序)
&lt;/h1&gt;&lt;p&gt;使用散列函数来确定元素的存储位置。
散列表的查找、插入和删除速度都非常快。
结果必须是均匀分布的，&lt;/p&gt;
&lt;h2 id=&#34;51-散列函数&#34;&gt;5.1 散列函数
&lt;/h2&gt;&lt;p&gt;“将输入映射到数字”&lt;br&gt;
必须满足要求：
（1）它必须是一致的（总是将同样的输入映射到相同的索引）
（2）它应将不同的输入映射到不同的数字。
（3）散列函数知道数组有多大，只返回有效的索引。&lt;br&gt;
散列表：散列表由键和值组成。是一种结合使用散列函数和数组创建的数据结构。&lt;/p&gt;
&lt;h2 id=&#34;52-应用案例&#34;&gt;5.2 应用案例
&lt;/h2&gt;&lt;h3 id=&#34;521-将散列表用于查找&#34;&gt;5.2.1 将散列表用于查找
&lt;/h3&gt;&lt;p&gt;提供DNS解析（将网址映射到IP地址）&lt;/p&gt;
&lt;h3 id=&#34;522-防止重复&#34;&gt;5.2.2 防止重复
&lt;/h3&gt;&lt;p&gt;使用散列表来检查是否重复，速度非常快。&lt;/p&gt;
&lt;h3 id=&#34;523-将散列表用作缓存&#34;&gt;5.2.3 将散列表用作缓存
&lt;/h3&gt;&lt;p&gt;缓存的数据存储在散列表中&lt;br&gt;
缓存的工作原理：网站将数据记住，而不再重新计算。&lt;br&gt;
优点：
（1）用户能够更快地看到网页
（2）需要做的工作更少&lt;/p&gt;
&lt;h2 id=&#34;53-冲突&#34;&gt;5.3 冲突
&lt;/h2&gt;&lt;p&gt;给两个键分配的位置相同。&lt;br&gt;
处理冲突的方式：如果两个键映射到了同一个位置，就在这个位置存储一个链表。&lt;br&gt;
要避免冲突，需要有：
(1)较低的填装因子；
(2)良好的散列函数。&lt;/p&gt;
&lt;h2 id=&#34;54-性能&#34;&gt;5.4 性能
&lt;/h2&gt;&lt;p&gt;&lt;img src=&#34;https://oslinss.github.io/708a4340-5af9-4ee4-9d87-26afcc179e4a-1.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;alt text&#34;
	
	
&gt;&lt;/p&gt;
&lt;h3 id=&#34;541-填装因子&#34;&gt;5.4.1 填装因子
&lt;/h3&gt;&lt;p&gt;&lt;img src=&#34;https://oslinss.github.io/47f89431-92f9-4bbc-b563-d27c7c2901da-1.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;alt text&#34;
	
	
&gt;
散列表使用数组来存储数据
填装因子度量的是散列表中有多少位置是空的&lt;br&gt;
调整长度：一旦填装因子开始增大（超过0.7），你就需要在散列表中添加位置&lt;/p&gt;
&lt;h3 id=&#34;542-良好的散列函数&#34;&gt;5.4.2 良好的散列函数
&lt;/h3&gt;&lt;p&gt;良好的散列函数让数组中的值呈均匀分布。&lt;/p&gt;
&lt;h1 id=&#34;6-广度优先搜索&#34;&gt;6 广度优先搜索
&lt;/h1&gt;&lt;p&gt;解决最短路径问题的算法被称为广度优先搜索。&lt;/p&gt;
&lt;h2 id=&#34;61-图简介&#34;&gt;6.1 图简介
&lt;/h2&gt;&lt;p&gt;(1) 使用图来建立问题模型。
(2) 使用广度优先搜索解决问题。&lt;/p&gt;
&lt;h2 id=&#34;62-图是什么&#34;&gt;6.2 图是什么
&lt;/h2&gt;&lt;p&gt;图由节点（node）和边（edge）组成。一个节点可能与众多节点直接相连，这些节点被称为邻居。&lt;/p&gt;
&lt;h2 id=&#34;63-广度优先搜索&#34;&gt;6.3 广度优先搜索
&lt;/h2&gt;&lt;p&gt;广度优先搜索是一种用于图的查找算法，可解决问题：
第一类问题：从节点A出发，有前往节点B的路径吗？
第二类问题：从节点A出发，前往节点B的哪条路径最短？&lt;/p&gt;
&lt;h3 id=&#34;631-查找最短路径&#34;&gt;6.3.1 查找最短路径
&lt;/h3&gt;&lt;p&gt;在广度优先搜索的执行过程中，搜索范围从起点开始逐渐向外延伸，即先检查一度关系，再检查二度关系。&lt;/p&gt;
&lt;h3 id=&#34;632-队列&#34;&gt;6.3.2 队列
&lt;/h3&gt;&lt;p&gt;队列类似于栈，你不能随机地访问队列中的元素。
队列只支持两种操作：入队和出队。&lt;br&gt;
&lt;font color=#DC143C&gt;队列是一种先进先出的数据结构，而栈是一种后进先出的数据结构。&lt;/font&gt;&lt;/p&gt;
&lt;h2 id=&#34;64-实现图&#34;&gt;6.4 实现图
&lt;/h2&gt;&lt;p&gt;有向图：关系是单向
无向图：没有箭头，直接相连的节点互为邻居&lt;/p&gt;
&lt;h2 id=&#34;65-实现算法&#34;&gt;6.5 实现算法
&lt;/h2&gt;&lt;p&gt;在Python中，可使用函数deque来创建一个双端队列。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;21
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;22
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;23
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;24
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;25
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;26
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;27
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;28
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;from collections import deque  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;def person_is_seller(name):  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    return name[-1] == &amp;#39;m&amp;#39;  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;def search_queue(start):  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    search_queue = deque()  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    search_queue += graph[start]    
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    while search_queue:  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        person = search_queue.popleft()  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        if person_is_seller(person):  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            print(person + &amp;#34; is a mango seller&amp;#34;)  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            return True  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        else:  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            search_queue += graph[person]  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    return False  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;graph = {}  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;graph[&amp;#34;you&amp;#34;] = [&amp;#34;alice&amp;#34;, &amp;#34;bob&amp;#34;, &amp;#34;claire&amp;#34;]  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;graph[&amp;#34;bob&amp;#34;] = [&amp;#34;anuj&amp;#34;, &amp;#34;peggy&amp;#34;]  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;graph[&amp;#34;alice&amp;#34;] = [&amp;#34;peggy&amp;#34;]  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;graph[&amp;#34;claire&amp;#34;] = [&amp;#34;thom&amp;#34;, &amp;#34;jonny&amp;#34;]  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;graph[&amp;#34;anuj&amp;#34;] = []  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;graph[&amp;#34;peggy&amp;#34;] = []  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;graph[&amp;#34;thom&amp;#34;] = []  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;graph[&amp;#34;jonny&amp;#34;] = []  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;search_queue(&amp;#34;you&amp;#34;)
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h2 id=&#34;66-运行时间&#34;&gt;6.6 运行时间
&lt;/h2&gt;&lt;p&gt;广度优先搜索的运行时间为O(人数 + 边数)，这通常写作O(V + E)，其中V为顶点（vertice）数，E为边数。&lt;/p&gt;
&lt;h1 id=&#34;7-狄克斯特拉算法&#34;&gt;7 狄克斯特拉算法
&lt;/h1&gt;&lt;h2 id=&#34;71-使用狄克斯特拉算法&#34;&gt;7.1 使用狄克斯特拉算法
&lt;/h2&gt;&lt;p&gt;狄克斯特拉算法包含4个步骤。
(1) 找出“最便宜”的节点，即可在最短时间内到达的节点。
(2) 更新该节点的邻居的开销，其含义将稍后介绍。
(3) 重复这个过程，直到对图中的每个节点都这样做了。
(4) 计算最终路径。&lt;/p&gt;
&lt;h2 id=&#34;72-术语&#34;&gt;7.2 术语
&lt;/h2&gt;&lt;p&gt;狄克斯特拉算法用于每条边都有关联数字的图，这些数字称为权重
带权重的图称为加权图
不带权重的图称为非加权图&lt;br&gt;
狄克斯特拉算法只适用于有向无环图&lt;/p&gt;
&lt;h2 id=&#34;73-负权边&#34;&gt;7.3 负权边
&lt;/h2&gt;&lt;p&gt;如果有负权边，就不能使用狄克斯特拉算法。&lt;br&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;21
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;22
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;23
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;24
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;25
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;26
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;27
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;28
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;29
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;30
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;31
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;32
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;33
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;34
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;35
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;36
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;37
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;38
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;39
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;40
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;41
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;42
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;43
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;44
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;45
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;46
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;47
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;48
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;49
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;50
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;def find_lowest_cost_node(costs):
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    lowest_cost = float(&amp;#34;inf&amp;#34;)
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    lowest_cost_node = None
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    for node in costs:
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        cost = costs[node]
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        if cost &amp;lt; lowest_cost and node not in processed:
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            lowest_cost = cost
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            lowest_cost_node = node
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    return lowest_cost_node
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;graph={}
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;graph[&amp;#34;you&amp;#34;]=[&amp;#34;alice&amp;#34;,&amp;#34;bob&amp;#34;,&amp;#34;claire&amp;#34;]
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;graph[&amp;#34;start&amp;#34;] = {} 
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;graph[&amp;#34;start&amp;#34;][&amp;#34;a&amp;#34;] = 6 
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;graph[&amp;#34;start&amp;#34;][&amp;#34;b&amp;#34;] = 2    
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;graph[&amp;#34;a&amp;#34;] = {} 
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;graph[&amp;#34;a&amp;#34;][&amp;#34;fin&amp;#34;] = 1 
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;graph[&amp;#34;b&amp;#34;] = {} 
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;graph[&amp;#34;b&amp;#34;][&amp;#34;a&amp;#34;] = 3 
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;graph[&amp;#34;b&amp;#34;][&amp;#34;fin&amp;#34;] = 5 
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;graph[&amp;#34;fin&amp;#34;] = {}
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;infinity = float(&amp;#34;inf&amp;#34;) 
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;costs = {} 
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;costs[&amp;#34;a&amp;#34;] = 6 
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;costs[&amp;#34;b&amp;#34;] = 2 
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;costs[&amp;#34;fin&amp;#34;] = infinity
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;parents = {} 
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;parents[&amp;#34;a&amp;#34;] = &amp;#34;start&amp;#34; 
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;parents[&amp;#34;b&amp;#34;] = &amp;#34;start&amp;#34; 
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;parents[&amp;#34;fin&amp;#34;] = None
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;processed = []
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;node=find_lowest_cost_node(costs)
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;while node is not None:
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    cost=costs[node]
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    neighbors=graph[node]
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    for n in neighbors.keys():
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        new_cost=cost+neighbors[n]
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        if costs[n]&amp;gt;new_cost:
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            costs[n]=new_cost
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            parents[n]=node
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    processed.append(node)
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    node=find_lowest_cost_node(costs)
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;print(&amp;#34;Costs:&amp;#34;, costs)  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;print(&amp;#34;Parents:&amp;#34;, parents)  
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h1 id=&#34;8-贪婪算法&#34;&gt;8 贪婪算法
&lt;/h1&gt;&lt;p&gt;优点——简单易行
每步都采取最优的做法
狄克斯特拉算法&lt;/p&gt;
&lt;h2 id=&#34;np完全问题&#34;&gt;NP完全问题
&lt;/h2&gt;&lt;p&gt;旅行商问题和集合覆盖问题需要计算所有的解（阶乘函数），并从中选出最小/最短的那个&lt;br&gt;
面临NP完全问题时，最佳的做法是使用近似算法。
贪婪算法易于实现、运行速度快，是不错的近似算法。&lt;/p&gt;
&lt;h1 id=&#34;9-动态规划&#34;&gt;9 动态规划
&lt;/h1&gt;&lt;p&gt;动态规划先解决子问题，再逐步解决大问题。
&lt;img src=&#34;https://oslinss.github.io/03516fdb-75e4-42ec-c49c-852c726d37be-1.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;alt text&#34;
	
	
&gt;
&lt;img src=&#34;https://oslinss.github.io/fa79b792-d201-47ba-cfa1-c0060d9e96d4-1.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;alt text&#34;
	
	
&gt;
问题可分解为离散子问题时，可使用动态规划来解决。
每种动态规划解决方案都涉及网格。
单元格中的值通常就是你要优化的值。
每个单元格都是一个子问题，因此你需要考虑如何将问题分解为子问题。&lt;/p&gt;
&lt;h2 id=&#34;最长公共子序列之解决方案&#34;&gt;最长公共子序列之解决方案
&lt;/h2&gt;&lt;p&gt;&lt;img src=&#34;https://oslinss.github.io/6fcaf2fc-c80a-41a0-cf94-61fef1327c5d-1.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;alt text&#34;
	
	
&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;if word_a[i] == word_b[j]:
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  cell[i][j] = cell[i-1][j-1] + 1 
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;else: 
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  cell[i][j] = max(cell[i-1][j],cell[i][j-1]) 
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h2 id=&#34;10-k最近邻算法&#34;&gt;10 K最近邻算法
&lt;/h2&gt;&lt;p&gt;KNN用于分类和回归，需要考虑最近的邻居。
分类就是编组。&lt;/p&gt;
&lt;h3 id=&#34;1021-特征抽取&#34;&gt;10.2.1 特征抽取
&lt;/h3&gt;&lt;p&gt;特征抽取意味着将物品（如水果或用户）转换为一系列可比较的数字。
能否挑选合适的特征事关KNN算法的成败。&lt;/p&gt;
&lt;h2 id=&#34;102-创建推荐系统&#34;&gt;10.2 创建推荐系统
&lt;/h2&gt;&lt;h3 id=&#34;1022-回归&#34;&gt;10.2.2 回归
&lt;/h3&gt;&lt;p&gt;回归就是预测结果（如数字）。&lt;/p&gt;
&lt;h2 id=&#34;103-ocr&#34;&gt;10.3 OCR
&lt;/h2&gt;&lt;p&gt;OCR指的是光学字符识别（optical character recognition）
OCR算法提取线段、点和曲线等特征。
OCR的第一步是查看大量的数字图像并提取特征，这被称为训练（training）。&lt;/p&gt;
&lt;h1 id=&#34;11-算法&#34;&gt;11 算法
&lt;/h1&gt;&lt;h2 id=&#34;111-树&#34;&gt;11.1 树
&lt;/h2&gt;&lt;p&gt;二叉查找树：对于其中的每个节点，左子节点的值都比它小，而右子节点的值都比它大。
二叉查找树的插入和删除操作的速度要快得多。&lt;/p&gt;
&lt;h2 id=&#34;112-反向索引&#34;&gt;11.2 反向索引
&lt;/h2&gt;&lt;p&gt;一个散列表，将单词映射到包含它的页面。这种数据结构被称为反向索引（inverted index），常用于创建搜索引擎&lt;/p&gt;
&lt;h2 id=&#34;113-傅里叶变换&#34;&gt;11.3 傅里叶变换
&lt;/h2&gt;&lt;p&gt;傅里叶变换非常适合用于处理信号，可使用它来压缩音乐。&lt;/p&gt;
&lt;h2 id=&#34;114-并行算法&#34;&gt;11.4 并行算法
&lt;/h2&gt;&lt;p&gt;改善性能和可扩展性
并行性管理开销
负载均衡&lt;/p&gt;
&lt;h2 id=&#34;115-mapreduce&#34;&gt;11.5 MapReduce
&lt;/h2&gt;&lt;p&gt;MapReduce是一种流行的分布式算法，你可通过流行的开源工具Apache Hadoop来使用它。&lt;br&gt;
原理：
映射函数：它接受一个数组，并对其中的每个元素执行同样的处理（映射是将一个数组转换为另一个数组。）
归并函数：将很多项归并为一项。（归并是将一个数组转换为一个元素。下面是一个示例。）&lt;/p&gt;
&lt;h2 id=&#34;116-布隆过滤器和hyperloglog&#34;&gt;11.6 布隆过滤器和HyperLogLog
&lt;/h2&gt;&lt;p&gt;布隆过滤器是一种概率型数据结构
布隆过滤器的优点在于占用的存储空间很少&lt;br&gt;
HyperLogLog近似地计算集合中不同的元素数，而占用的内存空间却少得多。
面临海量数据且只要求答案八九不离十时，可考虑使用概率型算法！&lt;/p&gt;
&lt;h2 id=&#34;117-sha算法&#34;&gt;11.7 SHA算法
&lt;/h2&gt;&lt;p&gt;安全散列算法函数是散列函数。给定一个字符串，SHA返回其散列值。&lt;/p&gt;
&lt;h2 id=&#34;118-局部敏感的散列算法&#34;&gt;11.8 局部敏感的散列算法
&lt;/h2&gt;&lt;p&gt;对字符串做细微的修改，Simhash生成的散列值也只存在细微的差别&lt;/p&gt;
&lt;h2 id=&#34;119-diffie-hellman密钥交换&#34;&gt;11.9 Diffie-Hellman密钥交换
&lt;/h2&gt;&lt;p&gt;Diffie-Hellman使用两个密钥：公钥和私钥。&lt;/p&gt;
&lt;h2 id=&#34;1110-线性规划&#34;&gt;11.10 线性规划
&lt;/h2&gt;&lt;p&gt;线性规划用于在给定约束条件下最大限度地改善指定的指标。
线性规划使用Simplex算法&lt;/p&gt;
</description>
        </item>
        <item>
        <title>Note</title>
        <link>https://oslinss.github.io/p/note/</link>
        <pubDate>Wed, 02 Apr 2025 10:28:45 +0800</pubDate>
        
        <guid>https://oslinss.github.io/p/note/</guid>
        <description>&lt;h1 id=&#34;1-了解web及网络基础&#34;&gt;1 了解Web及网络基础
&lt;/h1&gt;&lt;h2 id=&#34;11-使用http协议访问web&#34;&gt;1.1 使用HTTP协议访问Web
&lt;/h2&gt;&lt;p&gt;  根据Web浏览器地址栏中指定的URL，Web浏览器从Web服务器端获取文件资源等信息，从而显示出Web页面。
  Web使用一种名为HTTP（超文本传输协议）的协议作为规范。&lt;/p&gt;
&lt;h2 id=&#34;12-http的诞生&#34;&gt;1.2 HTTP的诞生
&lt;/h2&gt;&lt;h3 id=&#34;121-为知识共享而规划的web&#34;&gt;1.2.1 为知识共享而规划的Web
&lt;/h3&gt;&lt;p&gt;  最初设想的基本理念是：借助多文档之间相互关联形成的超文本
（HyperText），连成可相互参阅的 WWW（World Wide Web，万维
网）。
  3 项 WWW 构建技术，分别是：把 SGML（Standard
Generalized Markup Language，标准通用标记语言）作为页面的文本标
记语言的 HTML（HyperText Markup Language，超文本标记语言）；作为文档传递协议的 HTTP ；指定文档所在地址的 URL（Uniform Resource Locator，统一资源定位符）。&lt;/p&gt;
&lt;h2 id=&#34;13-网络基础-tcpip&#34;&gt;1.3 网络基础 TCP/IP
&lt;/h2&gt;&lt;p&gt;  通常使用的网络（包括互联网）是在 TCP/IP 协议族的基础上运作的。而 HTTP 属于它内部的一个子集。&lt;/p&gt;
&lt;h3 id=&#34;131-tcpip-协议族&#34;&gt;1.3.1 TCP/IP 协议族
&lt;/h3&gt;&lt;p&gt;  TCP/IP 是互联网相关的各类协议族的总称
  不同的硬件、操作系统之间的通信，所有的这一切都需要一种规则。而我们就把这种规则称为协议（protocol）。&lt;/p&gt;
&lt;h3 id=&#34;132-tcpip-的分层管理&#34;&gt;1.3.2 TCP/IP 的分层管理
&lt;/h3&gt;&lt;p&gt;  CP/IP 协议族按层次分别分为以下 4 层：应用层、传输层、网络层和数据链路层。&lt;br&gt;
  应用层决定了向用户提供应用服务时通信的活动。TCP/IP 协议族内预存了各类通用的应用服务。比如, FTP ( File   Transfer Protocol,文件传输协议)和DNS( Domain Name System, 域名系统) 服务就是其中两类。HTTP 协议也处于该层。&lt;br/&gt;
  传输层:传输层对上层应用层，提供处于网络连接中的两台计算机之间的数据传输。在传输层有两个性质不同的协议: TCP ( Transmission Control Protocol, 传输控制协议) 和UDP ( User Data Protocol, 用户数据报协议) 。&lt;br/&gt;
  网络层(又名网络互连层)网络层用来处理在网络上流动的数据包。数据包是网络传输的最小数据单位。该层规定了通过怎样的路径(所谓的传输路线) 到达对方计算机， 并把数据包传送给对方。与对方计算机之间通过多台计算机或网络设备进行传输时， 网络层所起的作用就是在众多的选项内选择一条传输路线。&lt;br/&gt;
  链路层(又名数据链路层， 网络接口层)用来处理连接网络的硬件部分。包括控制操作系统、硬件的设备驱动、NIC ( Network Interface Card, 网络适配器, 即网卡), 及光纤等物理可见部分(还包括连接器等一切传输媒介) 。硬件上的范畴均在链路层的作用范围之内。&lt;/p&gt;
&lt;h3 id=&#34;133-tcpip通信传输流&#34;&gt;1.3.3 TCP/IP通信传输流
&lt;/h3&gt;&lt;p&gt;&lt;img src=&#34;https://oslinss.github.io/0120c3fe-11e9-43c0-8756-de473c65e8c0.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;
&lt;img src=&#34;https://oslinss.github.io/dbcafa0f-4a4a-4c99-c599-2863a32874a1.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;alt text&#34;
	
	
&gt;
封装（encapsulate）：把数据信息包装起来的做法。&lt;/p&gt;
&lt;h2 id=&#34;14-与-http-关系密切的协议--iptcp-和dns&#34;&gt;1.4 与 HTTP 关系密切的协议 : IP、TCP 和DNS
&lt;/h2&gt;&lt;h3 id=&#34;141-负责传输的ip协议&#34;&gt;1.4.1 负责传输的IP协议
&lt;/h3&gt;&lt;p&gt;  IP 协议的作用是把各种数据包传送给对方。要保证确实传送到对方那里，则需要满足各类条件。其中两个重要的条件是 IP 地址和 MAC地址（Media Access Control Address）。&lt;br/&gt;
  IP地址指明了节点被分配到的地址，MAC 地址是指网卡所属的固定
地址。IP 地址可以和 MAC 地址进行配对。IP 地址可变换，但 MAC地址基本上不会更改。&lt;br&gt;
  ARP 是一种用以解析地址的协议，根据通信方的 IP 地址就可以反查出对应的 MAC 地址。&lt;/p&gt;
&lt;h3 id=&#34;142-确保可靠性的-tcp-协议&#34;&gt;1.4.2 确保可靠性的 TCP 协议
&lt;/h3&gt;&lt;p&gt;  按层次分，TCP 位于传输层，提供可靠的字节流服务(为了方便传输，将大块数据分割成以报文段（segment）为单位的数据包进行管理。)。
  为了准确无误地将数据送达目标处，TCP 协议采用了三次握手（three-way handshaking）策略。
&lt;img src=&#34;https://oslinss.github.io/ba50c8b0-4edc-4264-fb0e-65d02bfbf251.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;alt text&#34;
	
	
&gt;&lt;/p&gt;
&lt;h2 id=&#34;15-负责域名解析的-dns&#34;&gt;1.5 负责域名解析的 DNS
&lt;/h2&gt;&lt;p&gt;  服务DNS（Domain Name System）服务是和 HTTP 协议一样位于应用层的协议。它提供域名到 IP 地址之间的解析服务
  计算机既可以被赋予 IP 地址，也可以被赋予主机名和域名。
  DNS 协议提供通过域名查找 IP 地址，或逆向从 IP 地址反查域名的服务。&lt;/p&gt;
&lt;h2 id=&#34;16-各种协议与-http-协议的关系&#34;&gt;1.6 各种协议与 HTTP 协议的关系
&lt;/h2&gt;&lt;p&gt;&lt;img src=&#34;https://oslinss.github.io/7ae050b9-8967-4e52-d54e-d0dd429aebb3.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;alt text&#34;
	
	
&gt;&lt;/p&gt;
&lt;h2 id=&#34;17-uri-和-urluniform-resource-identifier&#34;&gt;1.7 URI 和 URL（Uniform Resource Identifier）
&lt;/h2&gt;&lt;p&gt;  URL:使用 Web 浏览器等访问 Web 页面时需要输入的网页地址。&lt;/p&gt;
&lt;h3 id=&#34;171-统一资源标识符&#34;&gt;1.7.1 统一资源标识符
&lt;/h3&gt;&lt;p&gt;  Uniform
  规定统一的格式可方便处理多种不同类型的资源，而不用根据上下文环境来识别资源指定的访问方式。另外，加入新增的协议方案（如http: 或 ftp:）也更容易。&lt;br&gt;
  Resource
  资源的定义是“可标识的任何东西”。除了文档文件、图像或服务（例如当天的天气预报）等能够区别于其他类型的，全都可作为资源。另外，资源不仅可以是单一的，也可以是多数的集合体。&lt;br&gt;
  Identifier表示可标识的对象。也称为标识符。&lt;/p&gt;
&lt;h3 id=&#34;172-uri-格式&#34;&gt;1.7.2 URI 格式
&lt;/h3&gt;&lt;p&gt;&lt;img src=&#34;https://oslinss.github.io/4fc04d32-1261-4584-ea5a-f437a80c40ec.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;alt text&#34;
	
	
&gt;&lt;/p&gt;
&lt;h1 id=&#34;2-简单的http协议&#34;&gt;2 简单的HTTP协议
&lt;/h1&gt;&lt;h2 id=&#34;21-http协议用于客户端和服务器端之间的通信&#34;&gt;2.1 HTTP协议用于客户端和服务器端之间的通信
&lt;/h2&gt;&lt;p&gt;应用 HTTP 协议时，必定是一端担任客户端角色，另一端担任服务器端角色。&lt;br&gt;
请求访问文本或图像等资源的一端称为客户端，而提供资源响应的一端称为服务器端。&lt;/p&gt;
&lt;h2 id=&#34;22-通过请求和响应的交换达成通信&#34;&gt;2.2 通过请求和响应的交换达成通信
&lt;/h2&gt;&lt;p&gt;请求报文是由请求方法、请求 URI、协议版本、可选的请求首部字段和内容实体构成的。&lt;br&gt;
&lt;img src=&#34;https://oslinss.github.io/1f897e47-5c16-4d9b-9e16-81e12b885e97-1.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;alt text&#34;
	
	
&gt;
响应报文基本上由协议版本、状态码（表示请求成功或失败的数字代码）、用以解释状态码的原因短语、可选的响应首部字段以及实体主体构成。&lt;br&gt;
&lt;img src=&#34;https://oslinss.github.io/c1f35526-6350-431b-e90d-5820b238fa3d-1.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;alt text&#34;
	
	
&gt;&lt;/p&gt;
&lt;h2 id=&#34;23-http是不保存状态的协议&#34;&gt;2.3 HTTP是不保存状态的协议
&lt;/h2&gt;&lt;p&gt;HTTP 协议自身不具备保存之前发送过的请求或响应的功能(确保协议的可伸缩性)&lt;/p&gt;
&lt;h2 id=&#34;24-请求uri定位资源&#34;&gt;2.4 请求URI定位资源
&lt;/h2&gt;&lt;p&gt;HTTP 协议使用 URI 让客户端定位到资源（URI 的特定功能，在互联网上任意位置的资源都能访问到）&lt;/p&gt;
&lt;h2 id=&#34;25告知服务器意图的-http-方法&#34;&gt;2.5　告知服务器意图的 HTTP 方法
&lt;/h2&gt;&lt;p&gt;GET 方法用来请求访问已被 URI 识别的资源。&lt;br&gt;
POST 方法用来传输实体的主体。&lt;br&gt;
PUT 方法用来传输文&lt;br&gt;
HEAD方法获得报文首部HEAD,和 GET 方法一样，只是不返回报文主体部分。&lt;br&gt;
DELETE 方法用来删除文件,DELETE 方法按请求 URI 删除指定的资源。&lt;br&gt;
OPTIONS 方法用来查询针对请求 URI 指定的资源支持的方法。&lt;br&gt;
TRACE 方法是让 Web 服务器端将之前的请求通信环回给客户端的方法。&lt;br&gt;
CONNECT 方法要求在与代理服务器通信时建立隧道，实现用隧道协议进行 TCP 通信。
主要使用 SSL（Secure Sockets Layer，安全套接层）和 TLS（Transport Layer Security，传输层安全）协议把通信内容加 密后经网络隧道传输。&lt;/p&gt;
&lt;h2 id=&#34;26-使用方法下达命令&#34;&gt;2.6 使用方法下达命令
&lt;/h2&gt;&lt;p&gt;向请求 URI 指定的资源发送请求报文时，采用称为方法的命令。方法的作用在于，可以指定请求的资源按期望产生某种行为。&lt;/p&gt;
&lt;h2 id=&#34;27-持久连接节省通信量&#34;&gt;2.7 持久连接节省通信量
&lt;/h2&gt;&lt;h3 id=&#34;271-持久连接&#34;&gt;2.7.1 持久连接
&lt;/h3&gt;&lt;p&gt;持久连接的特点是，只要任意一端没有明确提出断开连接，则保持 TCP 连接状态。&lt;/p&gt;
&lt;h3 id=&#34;272-管线化&#34;&gt;2.7.2 管线化
&lt;/h3&gt;&lt;p&gt;管线化技术出现后，不用等待响应亦可直接发送下一个请求。&lt;/p&gt;
&lt;h2 id=&#34;28-使用cookie的状态管理&#34;&gt;2.8 使用Cookie的状态管理
&lt;/h2&gt;&lt;p&gt;Cookie 技术通过在请求和响应报文中写入 Cookie 信息来控制客户端的状态。&lt;/p&gt;
&lt;h1 id=&#34;3-http报文内的http信息&#34;&gt;3 HTTP报文内的HTTP信息
&lt;/h1&gt;&lt;h2 id=&#34;31-http报文&#34;&gt;3.1 HTTP报文
&lt;/h2&gt;&lt;p&gt;用于 HTTP 协议交互的信息被称为 HTTP 报文。
请求端的HTTP 报文叫做请求报文，
响应端的叫做响应报文。&lt;br&gt;
HTTP 报文大致可分为报文首部和报文主体两块。
&lt;img src=&#34;https://oslinss.github.io/73e4ba69-5e03-4589-fcea-502888e928a1-1.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;alt text&#34;
	
	
&gt;&lt;/p&gt;
&lt;h2 id=&#34;32-请求报文及响应报文的结构&#34;&gt;3.2 请求报文及响应报文的结构
&lt;/h2&gt;&lt;p&gt;&lt;img src=&#34;https://oslinss.github.io/7addd7c4-c3ff-4c47-94ce-46b34aca40b5-2.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;alt text&#34;
	
	
&gt;
&lt;img src=&#34;https://oslinss.github.io/39cf45e5-739b-48d3-8ba4-75e2e9efd9ea-1.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;alt text&#34;
	
	
&gt;&lt;br&gt;
请求报文和响应报文的首部内容数据组成：
请求行
包含用于请求的方法，请求 URI 和 HTTP 版本。
状态行
包含表明响应结果的状态码，原因短语和 HTTP 版本。
首部字段
包含表示请求和响应的各种条件和属性的各类首部。一般有 4 种首部，分别是：通用首部、请求首部、响应首部和实体首
部。
其可能包含 HTTP 的 RFC 里未定义的首部（Cookie等）。&lt;/p&gt;
&lt;h2 id=&#34;33-编码提升传输速率&#34;&gt;3.3 编码提升传输速率
&lt;/h2&gt;&lt;p&gt;通过在传输时编码，能有效地处理大量的访问请求。&lt;/p&gt;
&lt;h3 id=&#34;331-报文主体和实体主体的差异&#34;&gt;3.3.1 报文主体和实体主体的差异
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;报文
是 HTTP 通信中的基本单位，由 8 位组字节流（octet sequence，其中 octet 为 8 个比特）组成，通过 HTTP 通信传输。&lt;br&gt;&lt;/li&gt;
&lt;li&gt;实体
作为请求或响应的有效载荷数据（补充项）被传输，其内容由实体首部和实体主体组成。&lt;br&gt;
HTTP 报文的主体用于传输请求或响应的实体主体。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;332-压缩传输的内容编码&#34;&gt;3.3.2 压缩传输的内容编码
&lt;/h3&gt;&lt;p&gt;内容编码指明应用在实体内容上的编码格式，并保持实体信息原样压缩。内容编码后的实体由客户端接收并负责解码。
&lt;img src=&#34;https://oslinss.github.io/6e22af4a-36c9-44bd-c39c-6400bd835a1d-1.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;alt text&#34;
	
	
&gt;
常用的内容编码：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;gzip（GNU zip）&lt;/li&gt;
&lt;li&gt;compress（UNIX 系统的标准压缩）&lt;/li&gt;
&lt;li&gt;deflate（zlib）&lt;/li&gt;
&lt;li&gt;identity（不进行编码）&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;333-分割发送的分块传输编码&#34;&gt;3.3.3 分割发送的分块传输编码
&lt;/h3&gt;&lt;p&gt;分块传输编码：把实体主体分块的功能
&lt;img src=&#34;https://oslinss.github.io/b5dd5be8-a2bd-4190-88dd-0b5a7bda5562-1.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;alt text&#34;
	
	
&gt;
使用分块传输编码的实体主体会由接收的客户端负责解码，恢复到编码前的实体主体。&lt;/p&gt;
&lt;h2 id=&#34;34-发送多种数据的多部分对象集合&#34;&gt;3.4 发送多种数据的多部分对象集合
&lt;/h2&gt;&lt;p&gt;发送邮件时，我们可以在邮件里写入文字并添加多份附件。这是因为采用了 MIME（Multipurpose Internet Mail Extensions，多用途因特网邮
件扩展）机制，它允许邮件处理文本、图片、视频等多个不同类型的数据。&lt;br&gt;
MIME 扩展中会使用一种称为多部分对象集合（Multipart）的方法，来容纳多份不同类型的数据。&lt;br&gt;
多部分对象集合包含的对象如下。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;multipart/form-data
在 Web 表单文件上传时使用。&lt;br&gt;&lt;/li&gt;
&lt;li&gt;multipart/byteranges
状态码 206（Partial Content，部分内容）响应报文包含了多个范围的内容时使用。&lt;br&gt;&lt;/li&gt;
&lt;li&gt;multipart/form-data&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;Content-Type: multipart/form-data; boundary=AaB03x
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;--AaB03x
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;Content-Disposition: form-data; name=&amp;#34;field1&amp;#34;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;Joe Blow
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;--AaB03x
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;Content-Disposition: form-data; name=&amp;#34;pics&amp;#34;; filename=&amp;#34;file1.txt&amp;#34;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;Content-Type: text/plain
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;...
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;（file1.txt的数据）...
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;--AaB03x--
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;multipart/byteranges&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;HTTP/1.1 206 Partial Content
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;Date: Fri, 13 Jul 2012 02:45:26 GMT
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;Last-Modified: Fri, 31 Aug 2007 02:02:20 GMT
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;Content-Type: multipart/byteranges; boundary=THIS_STRING_SEPARATES
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;--THIS_STRING_SEPARATES
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;Content-Type: application/pdf
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;Content-Range: bytes 500-999/8000
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;...
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;（范围指定的数据）...
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;--THIS_STRING_SEPARATES
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;Content-Type: application/pdf
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;Content-Range: bytes 7000-7999/8000
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;...
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;（范围指定的数据）...--THIS_STRING_SEPARATES--
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h2 id=&#34;35-获取部分内容的范围请求&#34;&gt;3.5 获取部分内容的范围请求
&lt;/h2&gt;&lt;p&gt;指定范围发送的请求叫做范围请求（Range Request）。&lt;br&gt;
执行范围请求时，会用到首部字段 Range 来指定资源的 byte 范围。&lt;br&gt;
byte 范围的指定形式:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;5001~10 000 字节
&lt;code&gt;Range: bytes=5001-10000&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;从 5001 字节之后全部的
&lt;code&gt;Range: bytes=5001-&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;从一开始到 3000 字节和 5000~7000 字节的多重范围
&lt;code&gt;Range: bytes=-3000, 5000-7000&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;36-内容协商返回最合适的内容&#34;&gt;3.6 内容协商返回最合适的内容
&lt;/h2&gt;&lt;p&gt;内容协商机制是指客户端和服务器端就响应的资源内容进行交涉，然后提供给客户端最为适合的资源。内容协商会以响应资源的语言、字符集、编码方式等作为判断的基准。&lt;br&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;内容协商技术：
服务器驱动协商（Server-driven Negotiation）
由服务器端进行内容协商。以请求的首部字段为参考，在服务器端自动处理。但对用户来说，以浏览器发送的信息作为判定的依据，并不一定能筛选出最优内容。&lt;br&gt;&lt;/li&gt;
&lt;li&gt;客户端驱动协商（Agent-driven Negotiation）
由客户端进行内容协商的方式。用户从浏览器显示的可选项列表中手动选择。还可以利用 JavaScript 脚本在 Web 页面上自动进行上述选择。比如按 OS 的类型或浏览器类型，自行切换成 PC 版页面或手机版页面。&lt;br&gt;&lt;/li&gt;
&lt;li&gt;透明协商（Transparent Negotiation）
是服务器驱动和客户端驱动的结合体，是由服务器端和客户端各自进行内容协商的一种方法。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;4-返回结果的http状态码&#34;&gt;4 返回结果的HTTP状态码
&lt;/h1&gt;&lt;p&gt;HTTP 状态码负责表示客户端 HTTP 请求的返回结果、标记服务器端的处理是否正常、通知出现的错误等工作。&lt;/p&gt;
&lt;h2 id=&#34;41-状态码告知从服务器端返回的请求结果&#34;&gt;4.1 状态码告知从服务器端返回的请求结果
&lt;/h2&gt;&lt;p&gt;状态码的职责是当客户端向服务器端发送请求时，描述返回的请求结果。&lt;br&gt;
状态码的类别&lt;/p&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;序号&lt;/th&gt;
          &lt;th&gt;类别&lt;/th&gt;
          &lt;th&gt;原因短语&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;1XX&lt;/td&gt;
          &lt;td&gt;Informational（信息性状态码）&lt;/td&gt;
          &lt;td&gt;接收的请求正在处理&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;2XX&lt;/td&gt;
          &lt;td&gt;Success（成功状态码）&lt;/td&gt;
          &lt;td&gt;请求正常处理完毕&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;3XX&lt;/td&gt;
          &lt;td&gt;Redirection（重定向状态码）&lt;/td&gt;
          &lt;td&gt;需要进行附加操作以完成请求&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;4XX&lt;/td&gt;
          &lt;td&gt;Client Error（客户端错误状态码）&lt;/td&gt;
          &lt;td&gt;服务器无法处理请求&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;5XX&lt;/td&gt;
          &lt;td&gt;Server Error（服务器错误状态码）&lt;/td&gt;
          &lt;td&gt;服务器处理请求出错&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&#34;42-2xx-成功&#34;&gt;4.2 2XX 成功
&lt;/h2&gt;&lt;p&gt;2XX 的响应结果表明请求被正常处理了。&lt;/p&gt;
&lt;h3 id=&#34;421-200-ok&#34;&gt;4.2.1 200 OK
&lt;/h3&gt;&lt;p&gt;在响应报文内，随状态码一起返回的信息会因方法的不同而发生改变。&lt;/p&gt;
&lt;h3 id=&#34;422-204-no-content&#34;&gt;4.2.2 204 NO Content
&lt;/h3&gt;&lt;p&gt;该状态码代表服务器接收的请求已成功处理，但在返回的响应报文中不含实体的主体部分。另外，也不允许返回任何实体的主体。&lt;/p&gt;
&lt;h3 id=&#34;423-206-partial-content&#34;&gt;4.2.3 206 Partial Content
&lt;/h3&gt;&lt;p&gt;该状态码表示客户端进行了范围请求，而服务器成功执行了这部分的GET 请求。响应报文中包含由 Content-Range 指定范围的实体内容。&lt;/p&gt;
&lt;h2 id=&#34;43-3xx-重定向&#34;&gt;4.3 3XX 重定向
&lt;/h2&gt;&lt;p&gt;3XX 响应结果表明浏览器需要执行某些特殊的处理以正确处理请求。&lt;/p&gt;
&lt;h3 id=&#34;431-301-moved-permanently&#34;&gt;4.3.1 301 Moved Permanently
&lt;/h3&gt;&lt;p&gt;永久性重定向。该状态码表示请求的资源已被分配了新的 URI，以后应使用资源现在所指的 URI。&lt;/p&gt;
&lt;h3 id=&#34;432-302-found&#34;&gt;4.3.2 302 Found
&lt;/h3&gt;&lt;p&gt;临时性重定向。该状态码表示请求的资源已被分配了新的 URI，希望用户（本次）能使用新的 URI 访问。&lt;/p&gt;
&lt;h3 id=&#34;433-see-other&#34;&gt;4.3.3 See Other
&lt;/h3&gt;&lt;p&gt;该状态码表示由于请求对应的资源存在着另一个 URI，应使用 GET方法定向获取请求的资源。&lt;/p&gt;
&lt;h3 id=&#34;434-not-modified&#34;&gt;4.3.4 Not Modified
&lt;/h3&gt;&lt;p&gt;该状态码表示客户端发送附带条件的请求 2 时，服务器端允许请求访问资源，但未满足条件的情况。304 状态码返回时，不包含任何响应的主体部分。304 虽然被划分在 3XX 类别中，但是和重定向没有关系。&lt;br&gt;
2 附带条件的请求是指采用 GET方法的请求报文中包含 If-Match，If-Modified-Since，If-None-Match，If-Range，If-Unmodified-Since 中任一首部。&lt;/p&gt;
&lt;h3 id=&#34;435-307-temporary-redirect&#34;&gt;4.3.5 307 Temporary Redirect
&lt;/h3&gt;&lt;p&gt;临时重定向。该状态码与302Found有着相同的含义&lt;/p&gt;
&lt;h2 id=&#34;44-4xx-客户端错误&#34;&gt;4.4 4XX 客户端错误
&lt;/h2&gt;&lt;p&gt;4XX 的响应结果表明客户端是发生错误的原因所在。&lt;/p&gt;
&lt;h3 id=&#34;441-400-bad-request&#34;&gt;4.4.1 400 Bad Request
&lt;/h3&gt;&lt;p&gt;该状态码表示请求报文中存在语法错误。&lt;/p&gt;
&lt;h3 id=&#34;442-401-unauthorized&#34;&gt;4.4.2 401 Unauthorized
&lt;/h3&gt;&lt;p&gt;该状态码表示发送的请求需要有通过 HTTP 认证（BASIC 认证、DIGEST 认证）的认证信息。另外若之前已进行过 1 次请求，则表示用户认证失败。&lt;br&gt;
返回含有 401 的响应必须包含一个适用于被请求资源的 WWW-Authenticate 首部用以质询（challenge）用户信息。当浏览器初次接收到 401 响应，会弹出认证用的对话窗口。&lt;/p&gt;
&lt;h3 id=&#34;443-403-forbidden&#34;&gt;4.4.3 403 Forbidden
&lt;/h3&gt;&lt;p&gt;该状态码表明对请求资源的访问被服务器拒绝了。&lt;br&gt;
未获得文件系统的访问授权，访问权限出现某些问题（从未授权的发送源 IP 地址试图访问）等列举的情况都可能是发生 403 的原因。&lt;/p&gt;
&lt;h3 id=&#34;444-not-found&#34;&gt;4.4.4 Not Found
&lt;/h3&gt;&lt;p&gt;该状态码表明服务器上无法找到请求的资源。&lt;/p&gt;
&lt;h2 id=&#34;45-5xx-服务器错误&#34;&gt;4.5 5XX 服务器错误
&lt;/h2&gt;&lt;p&gt;5XX 的响应结果表明服务器本身发生错误。&lt;/p&gt;
&lt;h3 id=&#34;451-500-internal-server-error&#34;&gt;4.5.1 500 Internal Server Error
&lt;/h3&gt;&lt;p&gt;该状态码表明服务器端在执行请求时发生了错误。也有可能是 Web应用存在的 bug 或某些临时的故障。&lt;/p&gt;
&lt;h3 id=&#34;452-503-service-unavailable&#34;&gt;4.5.2 503 Service Unavailable
&lt;/h3&gt;&lt;p&gt;该状态码表明服务器暂时处于超负载或正在进行停机维护，现在无法处理请求。如果事先得知解除以上状况需要的时间，最好写入RetryAfter 首部字段再返回给客户端。&lt;/p&gt;
&lt;h1 id=&#34;5-与http协作的web服务器&#34;&gt;5 与HTTP协作的Web服务器
&lt;/h1&gt;&lt;p&gt;一台 Web 服务器可搭建多个独立域名的 Web 网站，也可作为通信路径上的中转服务器提升传输效率。&lt;/p&gt;
&lt;h2 id=&#34;51-用单台虚拟主机实现多个域名&#34;&gt;5.1 用单台虚拟主机实现多个域名
&lt;/h2&gt;&lt;p&gt;HTTP/1.1 规范允许一台 HTTP 服务器搭建多个 Web 站点。&lt;br&gt;
在相同的 IP 地址下，由于虚拟主机可以寄存多个不同主机名和域名的 Web 网站，因此在发送 HTTP 请求时，必须在 Host 首部内完整指定主机名或域名的 URI。&lt;/p&gt;
&lt;h2 id=&#34;52-通信数据转发程序-代理网关隧道&#34;&gt;5.2 通信数据转发程序 ：代理、网关、隧道
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;代理
代理是一种有转发功能的应用程序，它扮演了位于服务器和客户端“中间人”的角色，接收由客户端发送的请求并转发给服务器，同时也接收服务器返回的响应并转发给客户端。&lt;/li&gt;
&lt;li&gt;网关
网关是转发其他服务器通信数据的服务器，接收从客户端发送来的请求时，它就像自己拥有资源的源服务器一样对请求进行处理。有时客户端可能都不会察觉，自己的通信目标是一个网关。&lt;/li&gt;
&lt;li&gt;隧道
隧道是在相隔甚远的客户端和服务器两者之间进行中转，并保持双方通信连接的应用程序。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;521-代理&#34;&gt;5.2.1 代理
&lt;/h3&gt;&lt;p&gt;代理服务器的基本行为就是接收客户端发送的请求后转发给其他服务器。代理不改变请求 URI，会直接发送给前方持有资源的目标服务器。&lt;br&gt;
持有资源实体的服务器被称为源服务器。从源服务器返回的响应经过代理服务器后再传给客户端。&lt;br&gt;
在 HTTP 通信过程中，可级联多台代理服务器。请求和响应的转发会经过数台类似锁链一样连接起来的代理服务器。转发时，需要附加Via 首部字段以标记出经过的主机信息。&lt;br&gt;
使用代理服务器的理由有：利用缓存技术（稍后讲解）减少网络带宽的流量，组织内部针对特定网站的访问控制，以获取访问日志为主要目的，等等。&lt;br&gt;
代理有多种使用方法，按两种基准分类。一种是是否使用缓存，另一种是是否会修改报文。&lt;br&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;缓存代理
代理转发响应时，缓存代理（Caching Proxy）会预先将资源的副本（缓存）保存在代理服务器上。当代理再次接收到对相同资源的请求时，就可以不从源服务器那里获取资源，而是将之前缓存的资源作为响应返回。&lt;/li&gt;
&lt;li&gt;透明代理
转发请求或响应时，不对报文做任何加工的代理类型被称为透明代理（Transparent Proxy）。反之，对报文内容进行加工的代理被称为非透明代理。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;522-网关&#34;&gt;5.2.2 网关
&lt;/h2&gt;&lt;p&gt;网关的工作机制和代理十分相似。而网关能使通信线路上的服务器提供非 HTTP 协议服务。&lt;br&gt;
利用网关能提高通信的安全性，因为可以在客户端与网关之间的通信线路上加密以确保连接的安全。比如，网关可以连接数据库，使用SQL 语句查询数据。另外，在 Web 购物网站上进行信用卡结算时，网关可以和信用卡结算系统联动。
&lt;img src=&#34;https://oslinss.github.io/159608d5-f48d-4649-d971-11dd446851b7-1.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;alt text&#34;
	
	
&gt;&lt;/p&gt;
&lt;h3 id=&#34;523-隧道&#34;&gt;5.2.3 隧道
&lt;/h3&gt;&lt;p&gt;隧道的目的是确保客户端能与服务器进行安全的通信。&lt;br&gt;
隧道本身不会去解析 HTTP 请求。&lt;/p&gt;
&lt;h2 id=&#34;53-保存资源的缓存&#34;&gt;5.3 保存资源的缓存
&lt;/h2&gt;&lt;p&gt;缓存是指代理服务器或客户端本地磁盘内保存的资源副本。利用缓存可减少对源服务器的访问，因此也就节省了通信流量和通信时间。&lt;br&gt;
缓存服务器的优势在于利用缓存可避免多次从源服务器转发资源。&lt;/p&gt;
&lt;h3 id=&#34;531-缓存的有效期限&#34;&gt;5.3.1 缓存的有效期限
&lt;/h3&gt;&lt;p&gt;即使存在缓存，也会因为客户端的要求、缓存的有效期等因素，向源服务器确认资源的有效性。&lt;/p&gt;
&lt;h3 id=&#34;532-客户端的缓存&#34;&gt;5.3.2 客户端的缓存
&lt;/h3&gt;&lt;p&gt;浏览器缓存如果有效，就不必再向服务器请求相同的资源了，可以直接从本地磁盘内读取。&lt;br&gt;&lt;/p&gt;
&lt;h1 id=&#34;6-http首部&#34;&gt;6 HTTP首部
&lt;/h1&gt;&lt;p&gt;HTTP 协议的请求和响应报文中必定包含 HTTP 首部&lt;/p&gt;
&lt;h2 id=&#34;61-http报文首部&#34;&gt;6.1 HTTP报文首部
&lt;/h2&gt;&lt;p&gt;&lt;img src=&#34;https://oslinss.github.io/fd255c10-ef7b-4c30-dd82-197549634312-1.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;alt text&#34;
	
	
&gt;&lt;br&gt;
在请求中，HTTP 报文由方法、URI、HTTP 版本、HTTP 首部字段等部分构成。&lt;br&gt;
在响应中，HTTP 报文由 HTTP 版本、状态码（数字和原因短语）、HTTP 首部字段 3 部分构成。&lt;/p&gt;
&lt;h2 id=&#34;62-hhtp首部字段&#34;&gt;6.2 HHTP首部字段
&lt;/h2&gt;&lt;h3 id=&#34;621-http-首部字段传递重要信息&#34;&gt;6.2.1 HTTP 首部字段传递重要信息
&lt;/h3&gt;&lt;p&gt;HTTP 首部字段是构成 HTTP 报文的要素之一。在客户端与服务器之间以 HTTP 协议进行通信的过程中，无论是请求还是响应都会使用首部字段，它能起到传递额外重要信息的作用。&lt;/p&gt;
&lt;h3 id=&#34;622-http-首部字段结构&#34;&gt;6.2.2 HTTP 首部字段结构
&lt;/h3&gt;&lt;p&gt;HTTP 首部字段是由首部字段名和字段值构成的，中间用冒号“:” 分隔。&lt;/p&gt;
&lt;h3 id=&#34;623-4-种-http-首部字段类型&#34;&gt;6.2.3 4 种 HTTP 首部字段类型
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;通用首部字段（General Header Fields）
请求报文和响应报文两方都会使用的首部。&lt;/li&gt;
&lt;li&gt;请求首部字段（Request Header Fields）
从客户端向服务器端发送请求报文时使用的首部。补充了请求的附加内容、客户端信息、响应内容相关优先级等信息。&lt;/li&gt;
&lt;li&gt;响应首部字段（Response Header Fields）
从服务器端向客户端返回响应报文时使用的首部。补充了响应的附加内容，也会要求客户端附加额外的内容信息。&lt;/li&gt;
&lt;li&gt;实体首部字段（Entity Header Fields）
针对请求报文和响应报文的实体部分使用的首部。补充了资源内容更新时间等与实体有关的信息。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;624-http11首部字段一览&#34;&gt;6.2.4 HTTP/1.1首部字段一览
&lt;/h3&gt;&lt;p&gt;通用首部字段&lt;/p&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;首部字段名&lt;/th&gt;
          &lt;th&gt;说明&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;Cache-Control&lt;/td&gt;
          &lt;td&gt;控制缓存的行为&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;Connection&lt;/td&gt;
          &lt;td&gt;逐跳首部、连接的管理&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;Date&lt;/td&gt;
          &lt;td&gt;创建报文的日期时间&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;Pragma&lt;/td&gt;
          &lt;td&gt;报文指令&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;Trailer&lt;/td&gt;
          &lt;td&gt;报文末端的首部一览&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;Transfer-Encoding&lt;/td&gt;
          &lt;td&gt;指定报文主体的传输编码方式&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;Upgrade&lt;/td&gt;
          &lt;td&gt;升级为其他协议&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;Via&lt;/td&gt;
          &lt;td&gt;代理服务器的相关信息Warning 错误通知&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;请求首部字段&lt;/p&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;首部字段名&lt;/th&gt;
          &lt;th&gt;说明&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;Accept&lt;/td&gt;
          &lt;td&gt;用户代理可处理的媒体类型&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;Accept-Charset&lt;/td&gt;
          &lt;td&gt;优先的字符集&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;Accept-Encoding&lt;/td&gt;
          &lt;td&gt;优先的内容编码&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;Accept-Language&lt;/td&gt;
          &lt;td&gt;优先的语言（自然语言）&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;Authorization&lt;/td&gt;
          &lt;td&gt;Web认证信息&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;Expect&lt;/td&gt;
          &lt;td&gt;期待服务器的特定行为&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;From&lt;/td&gt;
          &lt;td&gt;用户的电子邮箱地址&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;Host&lt;/td&gt;
          &lt;td&gt;请求资源所在服务器&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;If-Match&lt;/td&gt;
          &lt;td&gt;比较实体标记（ETag）&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;If-Modified-Since&lt;/td&gt;
          &lt;td&gt;比较资源的更新时间&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;If-None-Match&lt;/td&gt;
          &lt;td&gt;比较实体标记（与 If-Match 相反）&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;If-Range&lt;/td&gt;
          &lt;td&gt;资源未更新时发送实体 Byte 的范围请求&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;If-Unmodified-Since&lt;/td&gt;
          &lt;td&gt;比较资源的更新时间（与If-Modified-Since相反）&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;Max-Forwards&lt;/td&gt;
          &lt;td&gt;最大传输逐跳数&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;Proxy-Authorization&lt;/td&gt;
          &lt;td&gt;代理服务器要求客户端的认证信息&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;Range&lt;/td&gt;
          &lt;td&gt;实体的字节范围请求&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;Referer&lt;/td&gt;
          &lt;td&gt;对请求中 URI 的原始获取方&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;TE&lt;/td&gt;
          &lt;td&gt;传输编码的优先级User-Agent HTTP 客户端程序的信息&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;响应首部字段&lt;/p&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;首部字段名&lt;/th&gt;
          &lt;th&gt;说明&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;Accept-Ranges&lt;/td&gt;
          &lt;td&gt;是否接受字节范围请求&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;Age&lt;/td&gt;
          &lt;td&gt;推算资源创建经过时间&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;ETag&lt;/td&gt;
          &lt;td&gt;资源的匹配信息&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;Location&lt;/td&gt;
          &lt;td&gt;令客户端重定向至指定URI&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;Proxy-Authenticate&lt;/td&gt;
          &lt;td&gt;代理服务器对客户端的认证信息&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;Retry-After&lt;/td&gt;
          &lt;td&gt;对再次发起请求的时机要求&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;Server&lt;/td&gt;
          &lt;td&gt;HTTP服务器的安装信息&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;Vary&lt;/td&gt;
          &lt;td&gt;代理服务器缓存的管理信息WWW-Authenticate 服务器对客户端的认证信息&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;实体首部字段&lt;/p&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;首部字段名&lt;/th&gt;
          &lt;th&gt;说明&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;Allow&lt;/td&gt;
          &lt;td&gt;资源可支持的HTTP方法&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;Content-Encoding&lt;/td&gt;
          &lt;td&gt;实体主体适用的编码方式&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;Content-Language&lt;/td&gt;
          &lt;td&gt;实体主体的自然语言&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;Content-Length&lt;/td&gt;
          &lt;td&gt;实体主体的大小（单位：字节）&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;Content-Location&lt;/td&gt;
          &lt;td&gt;替代对应资源的URI&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;Content-MD5&lt;/td&gt;
          &lt;td&gt;实体主体的报文摘要&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;Content-Range&lt;/td&gt;
          &lt;td&gt;实体主体的位置范围&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;Content-Type&lt;/td&gt;
          &lt;td&gt;实体主体的媒体类型&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;Expires&lt;/td&gt;
          &lt;td&gt;实体主体过期的日期时间Last-Modified 资源的最后修改日期时间&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;625-非-http11-首部字段&#34;&gt;6.2.5 非 HTTP/1.1 首部字段
&lt;/h3&gt;&lt;p&gt;在 HTTP 协议通信交互中使用到的首部字段，不限于 RFC2616 中定义的 47 种首部字段。&lt;br&gt;
这些非正式的首部字段统一归纳在 RFC4229 HTTP Header FieldRegistrations 中。&lt;/p&gt;
&lt;h3 id=&#34;626&#34;&gt;6.2.6
&lt;/h3&gt;&lt;p&gt;End-to-end 首部和 Hop-by-hop 首部
HTTP 首部字段将定义成缓存代理和非缓存代理的行为
端到端首部（End-to-end Header）&lt;br&gt;
分在此类别中的首部会转发给请求 / 响应对应的最终接收目标，且必须保存在由缓存生成的响应中，另外规定它必须被转发。&lt;br&gt;
逐跳首部（Hop-by-hop Header）&lt;br&gt;
分在此类别中的首部只对单次转发有效，会因通过缓存或代理而不再转发。HTTP/1.1 和之后版本中，如果要使用 hop-by-hop 首部，需提供 Connection 首部字段。&lt;br&gt;
除这 8 个首部字段之外，其他所有字段都属于端到端首部。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Connection&lt;/li&gt;
&lt;li&gt;Keep-Alive&lt;/li&gt;
&lt;li&gt;Proxy-Authenticate&lt;/li&gt;
&lt;li&gt;Proxy-Authorization&lt;/li&gt;
&lt;li&gt;Trailer&lt;/li&gt;
&lt;li&gt;TE&lt;/li&gt;
&lt;li&gt;Transfer-Encoding&lt;/li&gt;
&lt;li&gt;Upgrade&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;63-http11-通用首部字段&#34;&gt;6.3 HTTP/1.1 通用首部字段
&lt;/h2&gt;&lt;p&gt;通用首部字段是指，请求报文和响应报文双方都会使用的首部。&lt;/p&gt;
&lt;h3 id=&#34;631-cache-control&#34;&gt;6.3.1 Cache-Control
&lt;/h3&gt;&lt;p&gt;通过指定首部字段 Cache-Control 的指令，就能操作缓存的工作机制。&lt;br&gt;
缓存请求指令&lt;/p&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;指令&lt;/th&gt;
          &lt;th&gt;参数&lt;/th&gt;
          &lt;th&gt;说明&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;no-cache&lt;/td&gt;
          &lt;td&gt;无&lt;/td&gt;
          &lt;td&gt;强制向源服务器再次验证&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;no-store&lt;/td&gt;
          &lt;td&gt;无&lt;/td&gt;
          &lt;td&gt;不缓存请求或响应的任何内容&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;max-age = [ 秒]&lt;/td&gt;
          &lt;td&gt;必需&lt;/td&gt;
          &lt;td&gt;响应的最大Age值&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;max-stale( = [ 秒])&lt;/td&gt;
          &lt;td&gt;可省略&lt;/td&gt;
          &lt;td&gt;接收已过期的响应&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;min-fresh = [ 秒]&lt;/td&gt;
          &lt;td&gt;必需&lt;/td&gt;
          &lt;td&gt;期望在指定时间内的响应仍有效&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;no-transform&lt;/td&gt;
          &lt;td&gt;无&lt;/td&gt;
          &lt;td&gt;代理不可更改媒体类型&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;only-if-cached&lt;/td&gt;
          &lt;td&gt;无&lt;/td&gt;
          &lt;td&gt;从缓存获取资源&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;cache-extension&lt;/td&gt;
          &lt;td&gt;-&lt;/td&gt;
          &lt;td&gt;新指令标记（token）&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;缓存响应指令&lt;/td&gt;
          &lt;td&gt;&lt;/td&gt;
          &lt;td&gt;&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;指令&lt;/td&gt;
          &lt;td&gt;参数&lt;/td&gt;
          &lt;td&gt;说明&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;-&lt;/td&gt;
          &lt;td&gt;-&lt;/td&gt;
          &lt;td&gt;-&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;public&lt;/td&gt;
          &lt;td&gt;无&lt;/td&gt;
          &lt;td&gt;可向任意方提供响应的缓存&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;private&lt;/td&gt;
          &lt;td&gt;可省略&lt;/td&gt;
          &lt;td&gt;仅向特定用户返回响应&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;no-cache&lt;/td&gt;
          &lt;td&gt;可省略&lt;/td&gt;
          &lt;td&gt;缓存前必须先确认其有效性&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;no-store&lt;/td&gt;
          &lt;td&gt;无&lt;/td&gt;
          &lt;td&gt;不缓存请求或响应的任何内容&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;no-transform&lt;/td&gt;
          &lt;td&gt;无&lt;/td&gt;
          &lt;td&gt;代理不可更改媒体类型&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;must-revalidate&lt;/td&gt;
          &lt;td&gt;无&lt;/td&gt;
          &lt;td&gt;可缓存但必须再向源服务器进行确认&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;proxy-revalidate&lt;/td&gt;
          &lt;td&gt;无&lt;/td&gt;
          &lt;td&gt;要求中间缓存服务器对缓存的响应有效性再进行确认&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;max-age = [ 秒]&lt;/td&gt;
          &lt;td&gt;必需&lt;/td&gt;
          &lt;td&gt;响应的最大Age值&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;s-maxage = [ 秒]&lt;/td&gt;
          &lt;td&gt;必需&lt;/td&gt;
          &lt;td&gt;公共缓存服务器响应的最大Age值&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;cache-extension&lt;/td&gt;
          &lt;td&gt;-&lt;/td&gt;
          &lt;td&gt;新指令标记（token）&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;表示是否能缓存的指令
当指定使用 public 指令时，则明确表明其他用户也可利用缓存。
当指定 private 指令后，响应只以特定的用户作为对象，这与 public指令的行为相反。
使用 no-cache 指令的目的是为了防止从缓存中返回过期的资源。&lt;br&gt;
控制可执行缓存的对象的指令
当使用 no-store 指令时，暗示请求（和对应的响应）或响应中包含机密信息。&lt;br&gt;
指定缓存期限和认证的指令
当服务器返回的响应中包含 max-age 指令时，缓存服务器将不对资源的有效性再作确认，而 max-age 数值代表资源保存为缓存的最长时间。
min-fresh 指令要求缓存服务器返回至少还未过指定时间的缓存资源min-fresh 指令要求缓存服务器返回至少还未过指定时间的缓存资源。
使用 max-stale 可指示缓存资源，即使过期也照常接收。如果指令未指定参数值，那么无论经过多久，客户端都会接收响应；如果指令中指定了具体数值，那么即使过期，只要仍处于 max-stale指定的时间内，仍旧会被客户端接收。
使用 only-if-cached 指令表示客户端仅在缓存服务器本地缓存目标资源的情况下才会要求其返回。
使用 must-revalidate 指令，代理会向源服务器再次验证即将返回的响应缓存目前是否仍然有效。
proxy-revalidate 指令要求所有的缓存服务器在接收到客户端带有该指令的请求返回响应之前，必须再次验证缓存的有效性。
使用 no-transform 指令规定无论是在请求还是响应中，缓存都不能改变实体主体的媒体类型。这样做可防止缓存或代理压缩图片等类似操作
通过 cache-extension 标记（token），可以扩展 Cache-Control 首部字段内的指令。&lt;/p&gt;
&lt;h3 id=&#34;632-connection&#34;&gt;6.3.2 Connection
&lt;/h3&gt;&lt;p&gt;Connection 首部字段具备如下两个作用。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;控制不再转发给代理的首部字段
在客户端发送请求和服务器返回响应内，使用 Connection 首部字段，可控制不再转发给代理的首部字段（即 Hop-by-hop 首部）。&lt;/li&gt;
&lt;li&gt;管理持久连接
当服务器端想明确断开连接时，则指定Connection 首部字段的值为 Close。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;633-date&#34;&gt;6.3.3 Date
&lt;/h3&gt;&lt;p&gt;首部字段 Date 表明创建 HTTP 报文的日期和时间。
HTTP/1.1 协议使用在 RFC1123 中规定的日期时间的格式&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;Date: Tue, 03 Jul 2012 04:40:59 GMT
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h3 id=&#34;634-pragma&#34;&gt;6.3.4 Pragma
&lt;/h3&gt;&lt;p&gt;该首部字段属于通用首部字段，但只用在客户端发送的请求中。客户端会要求所有的中间服务器不返回缓存的资源。&lt;/p&gt;
&lt;h3 id=&#34;635-trailer&#34;&gt;6.3.5 Trailer
&lt;/h3&gt;&lt;p&gt;首部字段 Trailer 会事先说明在报文主体后记录了哪些首部字段。该首部字段可应用在 HTTP/1.1 版本分块传输编码时。&lt;/p&gt;
&lt;h3 id=&#34;636-transfer-encoding&#34;&gt;6.3.6 Transfer-Encoding
&lt;/h3&gt;&lt;p&gt;首部字段 Transfer-Encoding 规定了传输报文主体时采用的编码方式。
HTTP/1.1 的传输编码方式仅对分块传输编码有效。&lt;/p&gt;
&lt;h3 id=&#34;637-upgrade&#34;&gt;6.3.7 Upgrade
&lt;/h3&gt;&lt;p&gt;首部字段 Upgrade 用于检测 HTTP 协议及其他协议是否可使用更高的版本进行通信，其参数值可以用来指定一个完全不同的通信协议。&lt;/p&gt;
&lt;h3 id=&#34;638-via&#34;&gt;6.3.8 Via
&lt;/h3&gt;&lt;p&gt;使用首部字段 Via 是为了追踪客户端与服务器之间的请求和响应报文的传输路径。
报文经过代理或网关时，会先在首部字段 Via 中附加该服务器的信息，然后再进行转发。
首部字段 Via 不仅用于追踪报文的转发，还可避免请求回环的发生。所以必须在经过代理时附加该首部字段内容。&lt;/p&gt;
&lt;h3 id=&#34;639-warning&#34;&gt;6.3.9 Warning
&lt;/h3&gt;&lt;p&gt;该首部通常会告知用户一些与缓存相关的问题的警告&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;Warning: [警告码][警告的主机:端口号]“[警告内容]”([日期时间])
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;HTTP/1.1 警告码&lt;/p&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;警告码&lt;/th&gt;
          &lt;th&gt;警告内容&lt;/th&gt;
          &lt;th&gt;说明&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;110&lt;/td&gt;
          &lt;td&gt;Response is stale（响应已过期）&lt;/td&gt;
          &lt;td&gt;代理返回已过期的资源&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;111&lt;/td&gt;
          &lt;td&gt;Revalidation failed（再验证失败）&lt;/td&gt;
          &lt;td&gt;代理再验证资源有效性时失败（服务器无法到达等原因）&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;112&lt;/td&gt;
          &lt;td&gt;Disconnection operation（断开连接操作）&lt;/td&gt;
          &lt;td&gt;代理与互联网连接被故意切断&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;113&lt;/td&gt;
          &lt;td&gt;Heuristic expiration（试探性过期）&lt;/td&gt;
          &lt;td&gt;响应的使用期超过24小时（有效缓存的设定时间大于24小时的情况下）&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;199&lt;/td&gt;
          &lt;td&gt;Miscellaneous warning（杂项警告）&lt;/td&gt;
          &lt;td&gt;任意的警告内容&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;214&lt;/td&gt;
          &lt;td&gt;Transformation applied（使用了转换）&lt;/td&gt;
          &lt;td&gt;代理对内容编码或媒体类型等执行了某些处理时&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;299&lt;/td&gt;
          &lt;td&gt;Miscellaneous persistent warning（持久杂项警告）&lt;/td&gt;
          &lt;td&gt;任意的警告内容&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&#34;64-请求首部字段&#34;&gt;6.4 请求首部字段
&lt;/h2&gt;&lt;p&gt;请求首部字段是从客户端往服务器端发送请求报文中所使用的字段，用于补充请求的附加信息、客户端信息、对响应内容相关的优先级等内容。&lt;/p&gt;
&lt;h3 id=&#34;641-accept&#34;&gt;6.4.1 Accept
&lt;/h3&gt;&lt;p&gt;Accept 首部字段可通知服务器，用户代理能够处理的媒体类型及媒体类型的相对优先级。
当服务器提供多种内容时，将会首先返回权重值最高的媒体类型.&lt;/p&gt;
&lt;h3 id=&#34;642---accept-charset&#34;&gt;6.4.2   Accept-Charset
&lt;/h3&gt;&lt;p&gt;Accept-Charset 首部字段可用来通知服务器用户代理支持的字符集及字符集的相对优先顺序。另外，可一次性指定多种字符集。与首部字段 Accept 相同的是可用权重 q 值来表示相对优先级。&lt;/p&gt;
&lt;h3 id=&#34;643-accept-encoding&#34;&gt;6.4.3 Accept-Encoding
&lt;/h3&gt;&lt;p&gt;Accept-Encoding 首部字段用来告知服务器用户代理支持的内容编码及内容编码的优先级顺序。可一次性指定多种内容编码。&lt;/p&gt;
&lt;h3 id=&#34;644-accept-language&#34;&gt;6.4.4 Accept-Language
&lt;/h3&gt;&lt;p&gt;首部字段 Accept-Language 用来告知服务器用户代理能够处理的自然语言集（指中文或英文等）&lt;/p&gt;
&lt;h3 id=&#34;645-authorization&#34;&gt;6.4.5 Authorization
&lt;/h3&gt;&lt;p&gt;首部字段 Authorization 是用来告知服务器，用户代理的认证信息（证书值）。&lt;/p&gt;
&lt;h3 id=&#34;646-except&#34;&gt;6.4.6 Except
&lt;/h3&gt;&lt;p&gt;客户端使用首部字段 Expect 来告知服务器，期望出现的某种特定行为。因服务器无法理解客户端的期望作出回应而发生错误时，会返回状态码 417 Expectation Failed。&lt;/p&gt;
&lt;h3 id=&#34;647-from&#34;&gt;6.4.7 From
&lt;/h3&gt;&lt;p&gt;首部字段 From 用来告知服务器使用用户代理的用户的电子邮件地址。&lt;/p&gt;
&lt;h3 id=&#34;648-host&#34;&gt;6.4.8 Host
&lt;/h3&gt;&lt;p&gt;首部字段 Host 会告知服务器，请求的资源所处的互联网主机名和端口号。Host 首部字段在 HTTP/1.1 规范内是唯一一个必须被包含在请求内的首部字段。&lt;/p&gt;
&lt;h3 id=&#34;649-if-match&#34;&gt;6.4.9 If-Match
&lt;/h3&gt;&lt;p&gt;形如 If-xxx 这种样式的请求首部字段，都可称为条件请求。服务器接收到附带条件的请求后，只有判断指定条件为真时，才会执行请求。
使用星号（*）指定 If-Match 的字段值。针对这种情况，服务器将会忽略 ETag 的值，只要资源存在就处理请求。&lt;/p&gt;
&lt;h3 id=&#34;6410-if-modified-since&#34;&gt;6.4.10 If-Modified-Since
&lt;/h3&gt;&lt;p&gt;If-Modified-Since 用于确认代理或客户端拥有的本地资源的有效性。获取资源的更新日期时间，可通过确认首部字段 Last-Modified 来确定。&lt;/p&gt;
&lt;h3 id=&#34;6411-if-none-match&#34;&gt;6.4.11 If-None-Match
&lt;/h3&gt;&lt;p&gt;用于指定 If-None-Match 字段值的实体标记（ETag）值与请求资源的 ETag 不一致时，它就告知服务器处理该请求。
在 GET 或 HEAD 方法中使用首部字段 If-None-Match 可获取最新的资源。&lt;/p&gt;
&lt;h3 id=&#34;6412-if-range&#34;&gt;6.4.12 If-Range
&lt;/h3&gt;&lt;p&gt;它告知服务器若指定的 If Range 字段值（ETag 值或者时间）和请求资源的 ETag 值或时间相一致时，则作为范围请求处理。反之，则返回全体资源。&lt;/p&gt;
&lt;h3 id=&#34;6413-if-unmodified-since&#34;&gt;6.4.13 If-Unmodified-Since
&lt;/h3&gt;&lt;p&gt;它的作用的是告知服务器，指定的请求资源只有在字段值内指定的日期时间之后，未发生更新的情况下，才能处理请求。&lt;/p&gt;
&lt;h3 id=&#34;6414-max-forwards111&#34;&gt;6.4.14 Max-Forwards111
&lt;/h3&gt;&lt;p&gt;通过 TRACE 方法或 OPTIONS 方法，发送包含首部字段 Max Forwards 的请求时，该字段以十进制整数形式指定可经过的服务器最大数目。服务器在往下一个服务器转发请求之前，Max-Forwards 的值减 1 后重新赋值。当服务器接收到 Max-Forwards 值为 0 的请求时，则不再进行转发，而是直接返回响应。&lt;/p&gt;
&lt;h3 id=&#34;6415-proxy-authorization&#34;&gt;6.4.15 Proxy-Authorization
&lt;/h3&gt;&lt;p&gt;接收到从代理服务器发来的认证质询时，客户端会发送包含首部字段Proxy-Authorization 的请求，以告知服务器认证所需要的信息。&lt;/p&gt;
&lt;h3 id=&#34;6416-rangerange&#34;&gt;6.4.16 RangeRange
&lt;/h3&gt;&lt;p&gt;对于只需获取部分资源的范围请求，包含首部字段 Range 即可告知服务器资源的指定范围&lt;/p&gt;
&lt;h3 id=&#34;6417-refererreferer&#34;&gt;6.4.17 RefererReferer
&lt;/h3&gt;&lt;p&gt;首部字段 Referer 会告知服务器请求的原始资源的 URI。&lt;/p&gt;
&lt;h3 id=&#34;6418-te&#34;&gt;6.4.18 TE
&lt;/h3&gt;&lt;p&gt;首部字段 TE 会告知服务器客户端能够处理响应的传输编码方式及相对优先级。
首部字段 TE 除指定传输编码之外，还可以指定伴随 trailer 字段的分块传输编码的方式。&lt;/p&gt;
&lt;h3 id=&#34;6419-user-agent&#34;&gt;6.4.19 User-Agent
&lt;/h3&gt;&lt;p&gt;首部字段 User-Agent 会将创建请求的浏览器和用户代理名称等信息传达给服务器。&lt;/p&gt;
&lt;h2 id=&#34;65-响应首部字段&#34;&gt;6.5 响应首部字段
&lt;/h2&gt;&lt;p&gt;响应首部字段是由服务器端向客户端返回响应报文中所使用的字段，用于补充】响应的附加信息、服务器信息，以及对客户端的附加要求等信息。&lt;/p&gt;
&lt;h3 id=&#34;651-accept-ranges&#34;&gt;6.5.1 Accept-Ranges
&lt;/h3&gt;&lt;p&gt;首部字段 Accept-Ranges 是用来告知客户端服务器是否能处理范围请求，以指定获取服务器端某个部分的资源。
可指定的字段值有两种，可处理范围请求时指定其为 bytes，反之则指定其为 none。&lt;/p&gt;
&lt;h3 id=&#34;652-age&#34;&gt;6.5.2 Age
&lt;/h3&gt;&lt;p&gt;首部字段 Age 能告知客户端，源服务器在多久前创建了响应。字段值的单位为秒。
若创建该响应的服务器是缓存服务器，Age 值是指缓存后的响应再次发起认证到认证完成的时间值。代理创建响应时必须加上首部字段Age。&lt;/p&gt;
&lt;h3 id=&#34;653-etag&#34;&gt;6.5.3 ETag
&lt;/h3&gt;&lt;p&gt;首部字段 ETag 能告知客户端实体标识。它是一种可将资源以字符串形式做唯一性标识的方式。服务器会为每份资源分配对应的 ETag值。&lt;br&gt;
强 ETag 值，不论实体发生多么细微的变化都会改变其值。
弱 ETag 值只用于提示资源是否相同。只有资源发生了根本改变，产生差异时才会改变 ETag 值。这时，会在字段值最开始处附加 W/。&lt;/p&gt;
&lt;h3 id=&#34;654-location&#34;&gt;6.5.4 Location
&lt;/h3&gt;&lt;p&gt;使用首部字段 Location 可以将响应接收方引导至某个与请求 URI 位置不同的资源。&lt;/p&gt;
&lt;h3 id=&#34;655-proxy-authenticate&#34;&gt;6.5.5 Proxy-Authenticate
&lt;/h3&gt;&lt;p&gt;首部字段 Proxy-Authenticate 会把由代理服务器所要求的认证信息发送给客户端。&lt;/p&gt;
&lt;h3 id=&#34;retry-after&#34;&gt;Retry-After
&lt;/h3&gt;&lt;p&gt;首部字段 Retry-After 告知客户端应该在多久之后再次发送请求。主要配合状态码 503 Service Unavailable 响应，或 3xx Redirect 响应一起使用。
字段值可以指定为具体的日期时间（Wed, 04 Jul 2012 06：34：24GMT 等格式），也可以是创建响应后的秒数。&lt;/p&gt;
&lt;h3 id=&#34;657-server&#34;&gt;6.5.7 Server
&lt;/h3&gt;&lt;p&gt;首部字段 Server 告知客户端当前服务器上安装的 HTTP 服务器应用程序的信息。不单单会标出服务器上的软件应用名称，还有可能包括版本号和安装时启用的可选项。&lt;/p&gt;
&lt;h3 id=&#34;658-vary&#34;&gt;6.5.8 Vary
&lt;/h3&gt;&lt;p&gt;当代理服务器接收到带有 Vary 首部字段指定获取资源的请求时，如果使用的Accept-Language 字段的值相同，那么就直接从缓存返回响应。反之，则需要先从源服务器端获取资源后才能作为响应返回&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;Vary: Accept-Language
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;首部字段 Vary 可对缓存进行控制。源服务器会向代理服务器传达关于本地缓存使用方法的命令。&lt;/p&gt;
&lt;h3 id=&#34;659-www-authenticate&#34;&gt;6.5.9 WWW-Authenticate
&lt;/h3&gt;&lt;p&gt;首部字段 WWW-Authenticate 用于 HTTP 访问认证。它会告知客户端适用于访问请求 URI 所指定资源的认证方案（Basic 或是 Digest）和带参数提示的质询（challenge）。&lt;/p&gt;
&lt;h2 id=&#34;66-实体首部字段&#34;&gt;6.6 实体首部字段
&lt;/h2&gt;&lt;p&gt;实体首部字段是包含在请求报文和响应报文中的实体部分所使用的首部，用于补充内容的更新时间等与实体相关的信息。&lt;/p&gt;
&lt;h3 id=&#34;661-allow&#34;&gt;6.6.1 Allow
&lt;/h3&gt;&lt;p&gt;首部字段 Allow 用于通知客户端能够支持 Request-URI 指定资源的所有 HTTP 方法。当服务器接收到不支持的 HTTP 方法时，会以状态码405 Method Not Allowed 作为响应返回。与此同时，还会把所有能支持的 HTTP 方法写入首部字段 Allow 后返回。&lt;/p&gt;
&lt;h3 id=&#34;662-content-encoding&#34;&gt;6.6.2 Content-Encoding
&lt;/h3&gt;&lt;p&gt;首部字段 Content-Encoding 会告知客户端服务器对实体的主体部分选用的内容编码方式。内容编码是指在不丢失实体信息的前提下所进行的压缩。&lt;br&gt;
内容编码方式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;gzip&lt;/li&gt;
&lt;li&gt;compress&lt;/li&gt;
&lt;li&gt;deflate&lt;/li&gt;
&lt;li&gt;identity&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;663-content-language&#34;&gt;6.6.3 Content-Language
&lt;/h3&gt;&lt;p&gt;首部字段 Content-Language 会告知客户端，实体主体使用的自然语言（指中文或英文等语言）。&lt;/p&gt;
&lt;h3 id=&#34;content-length&#34;&gt;Content-Length
&lt;/h3&gt;&lt;p&gt;首部字段 Content-Length 表明了实体主体部分的大小（单位是字节）。对实体主体进行内容编码传输时，不能再使用 Content-Length首部字段。&lt;/p&gt;
&lt;h3 id=&#34;665-content-location&#34;&gt;6.6.5 Content-Location
&lt;/h3&gt;&lt;p&gt;首部字段 Content-Location 给出与报文主体部分相对应的 URI。和首部字段 Location 不同，Content-Location 表示的是报文主体返回资源对应的 URI。&lt;/p&gt;
&lt;h3 id=&#34;666-content-md5&#34;&gt;6.6.6 Content-MD5
&lt;/h3&gt;&lt;p&gt;首部字段 Content-MD5 是一串由 MD5 算法生成的值，其目的在于检查报文主体在传输过程中是否保持完整，以及确认传输到达。&lt;/p&gt;
&lt;h3 id=&#34;667-content-range&#34;&gt;6.6.7 Content-Range
&lt;/h3&gt;&lt;p&gt;针对范围请求，返回响应时使用的首部字段 Content-Range，能告知客户端作为响应返回的实体的哪个部分符合范围请求。字段值以字节为单位，表示当前发送部分及整个实体大小。&lt;/p&gt;
&lt;h3 id=&#34;668-content-type&#34;&gt;6.6.8 Content-Type
&lt;/h3&gt;&lt;p&gt;首部字段 Content-Type 说明了实体主体内对象的媒体类型。和首部字段 Accept 一样，字段值用 type/subtype 形式赋值。&lt;/p&gt;
&lt;h3 id=&#34;669-expires&#34;&gt;6.6.9 Expires
&lt;/h3&gt;&lt;p&gt;首部字段 Expires 会将资源失效的日期告知客户端。缓存服务器在接收到含有首部字段 Expires 的响应后，会以缓存来应答请求，在Expires 字段值指定的时间之前，响应的副本会一直被保存。当超过指定的时间后，缓存服务器在请求发送过来时，会转向源服务器请求资源。&lt;/p&gt;
&lt;h3 id=&#34;6610-last-modified&#34;&gt;6.6.10 Last-Modified
&lt;/h3&gt;&lt;p&gt;首部字段 Last-Modified 指明资源最终修改的时间。&lt;/p&gt;
&lt;h2 id=&#34;67-为cookie服务的首部字段&#34;&gt;6.7 为Cookie服务的首部字段
&lt;/h2&gt;&lt;p&gt;Cookie 的工作机制是用户识别及状态管理。Web 网站为了管理用户的状态会通过 Web 浏览器，把一些数据临时写入用户的计算机内。接着当用户访问该Web网站时，可通过通信方式取回之前发放的Cookie。&lt;br&gt;&lt;/p&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;首部字段名&lt;/th&gt;
          &lt;th&gt;说明&lt;/th&gt;
          &lt;th&gt;首部类型&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;Set-Cookie&lt;/td&gt;
          &lt;td&gt;开始状态管理所使用的Cookie信息&lt;/td&gt;
          &lt;td&gt;响应首部字段&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;Cookie&lt;/td&gt;
          &lt;td&gt;服务器接收到的Cookie信息&lt;/td&gt;
          &lt;td&gt;请求首部字段&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;671-set-cookie&#34;&gt;6.7.1 Set-Cookie
&lt;/h3&gt;&lt;p&gt;当服务器准备开始管理客户端的状态时，会事先告知各种信息。&lt;br&gt;
Set-Cookie字段的属性&lt;/p&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;属性&lt;/th&gt;
          &lt;th&gt;说明&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;NAME=VALUE&lt;/td&gt;
          &lt;td&gt;赋予 Cookie 的名称和其值（必需项）&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;expires=DATE&lt;/td&gt;
          &lt;td&gt;Cookie 的有效期（若不明确指定则默认为浏览器关闭前为止）&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;path=PATH&lt;/td&gt;
          &lt;td&gt;将服务器上的文件目录作为Cookie的适用对象（若不指定则默认为文档所在的文件目录）&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;domain=域名&lt;/td&gt;
          &lt;td&gt;作为 Cookie 适用对象的域名 （若不指定则默认为创建 Cookie的服务器的域名）&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;Secure&lt;/td&gt;
          &lt;td&gt;仅在 HTTPS 安全通信时才会发送&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;CookieHttpOnly&lt;/td&gt;
          &lt;td&gt;加以限制，使 Cookie 不能被 JavaScript 脚本访问&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;672-cookie&#34;&gt;6.7.2 Cookie
&lt;/h3&gt;&lt;p&gt;首部字段 Cookie 会告知服务器，当客户端想获得 HTTP 状态管理支持时，就会在请求中包含从服务器接收到的 Cookie。接收到多个Cookie 时，同样可以以多个 Cookie 形式发送。&lt;/p&gt;
&lt;h2 id=&#34;68-其他首部字段&#34;&gt;6.8 其他首部字段
&lt;/h2&gt;&lt;h3 id=&#34;681-x-frame-options&#34;&gt;6.8.1 X-Frame-Options
&lt;/h3&gt;&lt;p&gt;首部字段 X-Frame-Options 属于 HTTP 响应首部，用于控制网站内容在其他 Web 网站的 Frame 标签内的显示问题。其主要目的是为了防止点击劫持（clickjacking）攻击。&lt;br&gt;
可指定字段值：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;DENY ：拒绝&lt;/li&gt;
&lt;li&gt;SAMEORIGIN ：仅同源域名下的页面（Top-level-browsing￾context）匹配时许可。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;682-x-xss-protection&#34;&gt;6.8.2 X-XSS-Protection
&lt;/h3&gt;&lt;p&gt;首部字段 X-XSS-Protection 属于 HTTP 响应首部，它是针对跨站脚本攻击（XSS）的一种对策，用于控制浏览器 XSS 防护机制的开关。&lt;br&gt;
可指定字段值：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;0 ：将 XSS 过滤设置成无效状态&lt;/li&gt;
&lt;li&gt;1 ：将 XSS 过滤设置成有效状态&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;683-dnt&#34;&gt;6.8.3 DNT
&lt;/h3&gt;&lt;p&gt;首部字段 DNT 属于 HTTP 请求首部，其中 DNT 是 Do Not Track 的简称，意为拒绝个人信息被收集，是表示拒绝被精准广告追踪的一种方法。&lt;br&gt;
可指定的字段值&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;0 ：同意被追踪&lt;/li&gt;
&lt;li&gt;1 ：拒绝被追踪&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;由于首部字段 DNT 的功能具备有效性，所以 Web 服务器需要对 DNT做对应的支持。&lt;/p&gt;
&lt;h3 id=&#34;684-p3p&#34;&gt;6.8.4 P3P
&lt;/h3&gt;&lt;p&gt;首部字段 P3P 属于 HTTP 相应首部，通过利用 P3P（The Platform for Privacy Preferences，在线隐私偏好平台）技术，可以让 Web 网站上的个人隐私变成一种仅供程序可理解的形式，以达到保护用户隐私的目的。&lt;br&gt;
要进行 P3P 的设定，需按以下操作步骤进行。
步骤 1：创建 P3P 隐私
步骤 2：创建 P3P 隐私对照文件后，保存命名在 /w3c/p3p.xml
步骤 3：从 P3P 隐私中新建 Compact policies 后，输出到 HTTP 响应中。&lt;/p&gt;
&lt;h1 id=&#34;7-确保web安全的https&#34;&gt;7 确保Web安全的HTTPS
&lt;/h1&gt;&lt;p&gt;在 HTTP 协议中有可能存在信息窃听或身份伪装等安全问题。使用HTTPS 通信机制可以有效地防止这些问题。&lt;/p&gt;
&lt;h2 id=&#34;71-http的缺点&#34;&gt;7.1 HTTP的缺点
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;通信使用明文（不加密），内容可能会被窃听&lt;/li&gt;
&lt;li&gt;不验证通信方的身份，因此有可能遭遇伪装&lt;/li&gt;
&lt;li&gt;无法证明报文的完整性，所以有可能已遭篡改&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;711-通信使用明文可能会被窃听&#34;&gt;7.1.1 通信使用明文可能会被窃听
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;TCP/IP 是可能被窃听的网络&lt;/li&gt;
&lt;li&gt;加密处理防止被窃听
通信的加密
HTTP 协议中没有加密机制，但可以通过和 SSL（Secure Socket Layer，安全套接层）或TLS（Transport Layer Security，安全层传输协议）的组合使用，加密 HTTP 的通信。&lt;br&gt;
内容加密
由于 HTTP 协议中没有加密机制，那么就对 HTTP 协议传输的内容本身加密。即把HTTP 报文里所含的内容进行加密处理。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;712-不验证通信方的身份就可能遭遇伪装&#34;&gt;7.1.2 不验证通信方的身份就可能遭遇伪装
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;任何人都可发起请求
* 无法确定请求发送至目标的 Web 服务器是否是按真实意图返回响应的那台服务器。有可能是已伪装的 Web 服务器。
* 无法确定响应返回到的客户端是否是按真实意图接收响应的那个客户端。有可能是已伪装的客户端。
* 无法确定正在通信的对方是否具备访问权限。因为某些Web 服务器上保存着重要的信息，只想发给特定用户通信的权限。
* 无法判定请求是来自何方、出自谁手。
* 即使是无意义的请求也会照单全收。无法阻止海量请求下的 DoS 攻击（Denial of Service，拒绝服务攻击）。&lt;/li&gt;
&lt;li&gt;查明对手的证书
&lt;img src=&#34;https://oslinss.github.io/a1c85bbb-a778-4829-d51d-0d6873bf6f7d-1.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;alt text&#34;
	
	
&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;713-无法证明报文完整性可能已遭篡改&#34;&gt;7.1.3 无法证明报文完整性，可能已遭篡改
&lt;/h3&gt;&lt;p&gt;所谓完整性是指信息的准确度。若无法证明其完整性，通常也就意味着无法判断信息是否准确。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;接收到的内容可能有误
由于 HTTP 协议无法证明通信的报文完整性，因此，在请求或响应送出之后直到对方接收之前的这段时间内，即使请求或响应的内容遭到篡改，也没有办法获悉。&lt;/li&gt;
&lt;li&gt;如何防止篡改
常用的是 MD5 和 SHA-1 等散列值校验的方法，以及用来确认文件的数字签名方法。
为了有效防止这些弊端，有必要使用 HTTPS。SSL提供认证和加密处理及摘要功能。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;72-http-加密--认证--完整性保护https&#34;&gt;7.2 HTTP+ 加密 + 认证 + 完整性保护=HTTPS
&lt;/h2&gt;&lt;h3 id=&#34;721-http-加上加密处理和认证以及完整性保护后即是https&#34;&gt;7.2.1 HTTP 加上加密处理和认证以及完整性保护后即是HTTPS
&lt;/h3&gt;&lt;p&gt;&lt;img src=&#34;https://oslinss.github.io/e06a1308-7d14-4bf5-bd7e-1a8aa2670dca-1.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;alt text&#34;
	
	
&gt;&lt;/p&gt;
&lt;h3 id=&#34;722-https-是身披-ssl-外壳的-http&#34;&gt;7.2.2 HTTPS 是身披 SSL 外壳的 HTTP
&lt;/h3&gt;&lt;p&gt;HTTPS 并非是应用层的一种新协议。只是 HTTP 通信接口部分用SSL（Secure Socket Layer）和 TLS（Transport Layer Security）协议代替。&lt;br&gt;
SSL是独立于 HTTP 的协议，所以不光是 HTTP 协议，其他运行在应用层的 SMTP 和 Telnet 等协议均可配合 SSL协议使用。可以说 SSL是当今世界上应用最为广泛的网络安全技术。&lt;/p&gt;
&lt;h3 id=&#34;723-相互交换密钥的公开密钥加密技术&#34;&gt;7.2.3 相互交换密钥的公开密钥加密技术
&lt;/h3&gt;&lt;p&gt;SSL采用一种叫做公开密钥加密（Public-key cryptography）的加密处理方式。&lt;br&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;共享密钥加密的困境
加密和解密同用一个密钥的方式称为共享密钥加密（Common keycrypto system），也被叫做对称密钥加密。&lt;/li&gt;
&lt;li&gt;使用两把密钥的公开密钥加密
公开密钥加密方式很好地解决了共享密钥加密的困难。
公开密钥加密使用一对非对称的密钥。一把叫做私有密钥（private key），另一把叫做公开密钥（public key）。&lt;/li&gt;
&lt;li&gt;HTTPS 采用混合加密机制
HTTPS 采用共享密钥加密和公开密钥加密两者并用的混合加密机制。&lt;br&gt;
&lt;img src=&#34;https://oslinss.github.io/570b55d0-c2e5-474b-88b3-6bb0c5066616-1.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;alt text&#34;
	
	
&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;724-证明公开密钥正确性的证书&#34;&gt;7.2.4 证明公开密钥正确性的证书
&lt;/h3&gt;&lt;p&gt;数字证书认证机构处于客户端与服务器双方都可信赖的第三方机构的立场上。&lt;br&gt;
服务器会将这份由数字证书认证机构颁发的公钥证书发送给客户端，以进行公开密钥加密方式通信。公钥证书也可叫做数字证书或直接称为证书。
接到证书的客户端可使用数字证书认证机构的公开密钥，对那张证书上的数字签名进行验证，一旦验证通过，客户端便可明确两件事：一，认证服务器的公开密钥的是真实有效的数字证书认证机构。二，服务器的公开密钥是值得信赖的。&lt;br&gt;
&lt;img src=&#34;https://oslinss.github.io/abc51a2f-3df7-489c-abb5-501d75af3a78-1.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;alt text&#34;
	
	
&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;可证明组织真实性的 EV SSL 证书
证书的一个作用是用来证明作为通信一方的服务器是否规范，另外一个作用是可确认对方服务器背后运营的企业是否真实存在。
拥有该特性的证书就是 EV SSL证书（Extended Validation SSLCertificate）。&lt;/li&gt;
&lt;li&gt;用以确认客户端的客户端证书
HTTPS 中还可以使用客户端证书。以客户端证书进行客户端认证，证明服务器正在通信的对方始终是预料之内的客户端。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;725-https的安全通信机制&#34;&gt;7.2.5 HTTPS的安全通信机制
&lt;/h3&gt;&lt;p&gt;HTTPS的通信步骤
步骤 1： 客户端通过发送 Client Hello 报文开始 SSL通信。报文中包含客户端支持的 SSL的指定版本、加密组件（Cipher Suite）列表（所使用的加密算法及密钥长度等）。
步骤 2： 服务器可进行 SSL通信时，会以 Server Hello 报文作为应答。和客户端一样，在报文中包含 SSL版本以及加密组件。服务器的加密组件内容是从接收到的客户端加密组件内筛选出来的。
步骤 3： 之后服务器发送 Certificate 报文。报文中包含公开密钥证书。
步骤 4： 最后服务器发送 Server Hello Done 报文通知客户端，最初阶段的 SSL握手协商部分结束。
步骤 5： SSL第一次握手结束之后，客户端以 Client Key Exchange 报文作为回应。报文中包含通信加密中使用的一种被称为 Pre-master secret 的随机密码串。该报文已用步骤 3中的公开密钥进行加密。
步骤 6： 接着客户端继续发送 Change Cipher Spec 报文。该报文会提示服务器，在此报文之后的通信会采用 Pre-master secret 密钥加密。
步骤 7： 客户端发送 Finished 报文。该报文包含连接至今全部报文的整体校验值。这次握手协商是否能够成功，要以服务器是否能够正确解密该报文作为判定标准。
步骤 8： 服务器同样发送 Change Cipher Spec 报文。
步骤 9： 服务器同样发送 Finished 报文。
步骤 10： 服务器和客户端的 Finished 报文交换完毕之后，SSL连接就算建立完成。当然，通信会受到 SSL的保护。从此处开始进行应用层协议的通信，即发送 HTTP 请求。
步骤 11： 应用层协议通信，即发送 HTTP 响应。
步骤 12： 最后由客户端断开连接。断开连接时，发送 close_notify 报文。上图做了一些省略，这步之后再发送 TCP FIN 报文来关闭与 TCP的通信。&lt;br&gt;
在以上流程中，应用层发送数据时会附加一种叫做 MAC（MessageAuthentication Code）的报文摘要。MAC 能够查知报文是否遭到篡改，从而保护报文的完整性。&lt;br&gt;
从仅使用服务器端的公开密钥证书（服务器证书）建立 HTTPS 通信的整个过程。
&lt;img src=&#34;https://oslinss.github.io/d1c66803-65a2-4abf-c720-279f2af1e4ec-1.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;alt text&#34;
	
	
&gt;
CBC 模式（Cipher Block Chaining）又名密码分组链接模式。在此模式下，将前一个明文块加密处理后和下一个明文块做 XOR 运算，使之重叠，然后再对运算结果做加密处理。对第一个明文块做加密时，要么使用前一段密文的最后一块，要么利用外部生成的初始向量（initial vector，IV）。&lt;br&gt;
当HTTPS使用 SSL时，它的处理速度会变慢。
SSL的慢分两种。一种是指通信慢。另一种是指由于大量消耗CPU 及内存等资源，导致处理速度变慢。&lt;/p&gt;
&lt;h1 id=&#34;8-确认访问用户身份的认证&#34;&gt;8 确认访问用户身份的认证
&lt;/h1&gt;&lt;h2 id=&#34;81-何为认证&#34;&gt;8.1 何为认证
&lt;/h2&gt;&lt;p&gt;核对的信息通常是指以下这些。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;密码：只有本人才会知道的字符串信息。&lt;/li&gt;
&lt;li&gt;动态令牌：仅限本人持有的设备内显示的一次性密码。&lt;/li&gt;
&lt;li&gt;数字证书：仅限本人（终端）持有的信息。&lt;/li&gt;
&lt;li&gt;生物认证：指纹和虹膜等本人的生理信息。&lt;/li&gt;
&lt;li&gt;IC 卡等：仅限本人持有的信息。
HTTP 使用的认证方式
HTTP/1.1 使用的认证方式如下所示。&lt;/li&gt;
&lt;li&gt;BASIC 认证（基本认证）&lt;/li&gt;
&lt;li&gt;DIGEST 认证（摘要认证）&lt;/li&gt;
&lt;li&gt;SSL 客户端认证&lt;/li&gt;
&lt;li&gt;FormBase 认证（基于表单认证）&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;82-basic认证&#34;&gt;8.2 BASIC认证
&lt;/h2&gt;&lt;p&gt;BASIC认证的认证步骤：
步骤 1： 当请求的资源需要 BASIC 认证时，服务器会随状态码 401Authorization Required，返回带 WWW-Authenticate 首部字段的响应。
该字段内包含认证的方式（BASIC） 及 Request-URI 安全域字符串
（realm）。
步骤 2： 接收到状态码 401 的客户端为了通过 BASIC 认证，需要将用户 ID 及密码发送给服务器。发送的字符串内容是由用户 ID 和密码构成，两者中间以冒号（:）连接后，再经过 Base64 编码处理。&lt;/p&gt;
&lt;h2 id=&#34;83-digest认证&#34;&gt;8.3 DIGEST认证
&lt;/h2&gt;&lt;p&gt;为弥补 BASIC 认证存在的弱点，从 HTTP/1.1 起就有了 DIGEST 认证。 DIGEST 认证同样使用质询 / 响应的方式（challenge/response），但不会像 BASIC 认证那样直接发送明文密码。&lt;br&gt;
所谓质询响应方式是指，一开始一方会先发送认证要求给另一方，接着使用从另一方那接收到的质询码计算生成响应码。最后将响应码返回给对方进行认证的方式。&lt;br&gt;
DIGEST 认证的认证步骤图：
步骤 1： 请求需认证的资源时，服务器会随着状态码 401Authorization Required，返 回带 WWW-Authenticate 首部字段的响应。该字段内包含质问响应方式认证所需的临时质询码（随机数，nonce）。
首部字段 WWW-Authenticate 内必须包含 realm 和 nonce 这两个字段的
信息。客户端就是依靠向服务器回送这两个值进行认证的。
nonce 是一种每次随返回的 401 响应生成的任意随机字符串。该字符
串通常推荐由 Base64 编码的十六进制数的组成形式，但实际内容依
赖服务器的具体实现。
步骤 2： 接收到 401 状态码的客户端，返回的响应中包含 DIGEST 认证必须的首部字段 Authorization 信息。
首部字段 Authorization 内必须包含 username、realm、nonce、uri 和response 的字段信息。其中，realm 和 nonce 就是之前从服务器接收到的响应中的字段。
username 是 realm 限定范围内可进行认证的用户名。
uri（digest-uri）即 Request-URI 的值，但考虑到经代理转发后Request-URI 的值可能被修改，因此事先会复制一份副本保存在 uri内。
response 也可叫做 Request-Digest，存放经过 MD5 运算后的密码字符串，形成响应码。
步骤 3： 接收到包含首部字段 Authorization 请求的服务器，会确认认证信息的正确性。认证通过后则返回包含 Request-URI 资源的响应。并且这时会在首部字段 Authentication-Info 写入一些认证成功的相关信
息。
DIGEST 认证提供了高于 BASIC 认证的安全等级，但是和 HTTPS 的客户端认证相比仍旧很弱。DIGEST 认证提供防止密码被窃听的保护机制，但并不存在防止用户伪装的保护机制。
DIGEST 认证和 BASIC 认证一样，使用上不那么便捷灵活，且仍达不到多数 Web 网站对高度安全等级的追求标准。因此它的适用范围也有所受限。&lt;/p&gt;
&lt;h2 id=&#34;84-ssl客户端认证&#34;&gt;8.4 SSL客户端认证
&lt;/h2&gt;&lt;p&gt;SSL客户端认证是借由 HTTPS 的客户端证书完成认证的方式。凭借客户端证书（在 HTTPS 一章已讲解）认证，服务器可确认访问是否来自已登录的客户端。&lt;/p&gt;
&lt;h3 id=&#34;841-ssl-客户端认证的认证步骤&#34;&gt;8.4.1 SSL 客户端认证的认证步骤
&lt;/h3&gt;&lt;p&gt;为达到 SSL客户端认证的目的，需要事先将客户端证书分发给客户
端，且客户端必须安装此证书。
步骤 1： 接收到需要认证资源的请求，服务器会发送 Certificate Request 报文，要求客户端提供客户端证书。
步骤 2： 用户选择将发送的客户端证书后，客户端会把客户端证书信息以 Client Certificate 报文方式发送给服务器。
步骤 3： 服务器验证客户端证书验证通过后方可领取证书内客户端的公开密钥，然后开始 HTTPS 加密通信。&lt;/p&gt;
&lt;h3 id=&#34;842-ssl客户端认证采用双因素认证&#34;&gt;8.4.2 SSL客户端认证采用双因素认证
&lt;/h3&gt;&lt;p&gt;双因素认证就是指，认证过程中不仅需要密码这一个因素，还需要申请认证者提供其他持有信息，从而作为另一个因素，与其组合使用的认证方式。
通过双因素认证后，就可以确认是用户本人正在使用匹配正确的计算机访问服务器。&lt;/p&gt;
&lt;h3 id=&#34;843-ssl-客户端认证必要的费用&#34;&gt;8.4.3 SSL 客户端认证必要的费用
&lt;/h3&gt;&lt;p&gt;使用 SSL客户端认证需要用到客户端证书。而客户端证书需要支付一定费用才能使用。&lt;/p&gt;
&lt;h2 id=&#34;85-基于表单认证&#34;&gt;8.5 基于表单认证
&lt;/h2&gt;&lt;p&gt;基于表单的认证方法并不是在 HTTP 协议中定义的。客户端会向服务器上的 Web 应用程序发送登录信息（Credential），按登录信息的验证结果认证。&lt;/p&gt;
&lt;h3 id=&#34;851-认证多半为基于表单认证&#34;&gt;8.5.1 认证多半为基于表单认证
&lt;/h3&gt;&lt;p&gt;对于 Web 网站的认证功能，能够满足其安全使用级别的标准规范并不存在，所以只好使用由 Web 应用程序各自实现基于表单的认证方式。&lt;/p&gt;
&lt;h3 id=&#34;852-session-管理及-cookie-应用&#34;&gt;8.5.2 Session 管理及 Cookie 应用
&lt;/h3&gt;&lt;p&gt;Session 管理及 Cookie 状态管理
步骤 1： 客户端把用户 ID 和密码等登录信息放入报文的实体部分，通常是以 POST 方法把请求发送给服务器。而这时，会使用 HTTPS通信来进行 HTML表单画面的显示和用户输入数据的发送。
步骤 2： 服务器会发放用以识别用户的 Session ID。通过验证从客户端发送过来的登录信息进行身份认证，然后把用户的认证状态与Session ID 绑定后记录在服务器端。
步骤 3： 客户端接收到从服务器端发来的 Session ID 后，会将其作为Cookie 保存在本地。下次向服务器发送请求时，浏览器会自动发送
Cookie，所以 Session ID 也随之发送到服务器。服务器端可通过验证接收到的 Session ID 识别用户和其认证状态。&lt;/p&gt;
&lt;h1 id=&#34;9-基于http的功能追加协议&#34;&gt;9 基于HTTP的功能追加协议
&lt;/h1&gt;&lt;h2 id=&#34;91-基于http的协议&#34;&gt;9.1 基于HTTP的协议
&lt;/h2&gt;&lt;p&gt;基于 HTTP 的 Web 浏览器的使用环境已遍布全球，因此无法完全抛弃HTTP。&lt;/p&gt;
&lt;h2 id=&#34;92-消除http瓶颈的spdy&#34;&gt;9.2 消除HTTP瓶颈的SPDY
&lt;/h2&gt;&lt;p&gt;开发目标旨在解决 HTTP 的性能瓶颈，缩短 Web 页面的加载时间（50%）。&lt;/p&gt;
&lt;h3 id=&#34;921-http的瓶颈&#34;&gt;9.2.1 HTTP的瓶颈
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;一条连接上只可发送一个请求。&lt;/li&gt;
&lt;li&gt;请求只能从客户端开始。客户端不可以接收除响应以外的指令。&lt;/li&gt;
&lt;li&gt;请求 / 响应首部未经压缩就发送。首部信息越多延迟越大。&lt;/li&gt;
&lt;li&gt;发送冗长的首部。每次互相发送相同的首部造成的浪费较多。&lt;/li&gt;
&lt;li&gt;可任意选择数据压缩格式。非强制压缩发送。
&lt;br&gt;
Ajax 的解决方法
Ajax（Asynchronous JavaScript and XML， 异 步 JavaScript 与 XML 技术）是一种有效利用 JavaScript 和 DOM（Document Object Model，文档对象模型）的操作，以达到局部 Web 页面替换加载的异步通信手段。和以前的同步通信相比，由于它只更新一部分页面，响应中传输的数据量会因此而减少。&lt;br&gt;
Ajax 的核心技术是名为 XMLHttpRequest 的 API，通过 JavaScript 脚本语言的调用就能和服务器进行 HTTP 通信。借由这种手段，就能从已加载完毕的 Web 页面上发起请求，只更新局部页面。&lt;br&gt;
Comet 的解决方法
一旦服务器端有内容更新了，Comet 不会让请求等待，而是直接给客户端返回响应。这是一种通过延迟应答，模拟实现服务器端向客户端推送（Server Push）的功能。&lt;br&gt;
SPDY 的目标
处于持续开发状态中的 SPDY 协议，正是为了在协议级别消除 HTTP所遭遇的瓶颈。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;922-spdy的设计与功能&#34;&gt;9.2.2 SPDY的设计与功能
&lt;/h3&gt;&lt;p&gt;SPDY 没有完全改写 HTTP 协议，而是在 TCP/IP 的应用层与运输层之间通过新加会话层的形式运作。
SPDY 以会话层的形式加入，控制对数据的流动，但还是采用 HTTP建立通信连接。&lt;br&gt;
使用 SPDY 后，HTTP 协议额外获得以下功能。
多路复用流
通过单一的 TCP 连接，可以无限制处理多个 HTTP 请求。所有请求的处理都在一条 TCP 连接上完成，因此 TCP 的处理效率得到提高。
赋予请求优先级
SPDY 不仅可以无限制地并发处理请求，还可以给请求逐个分配优先级顺序。这样主要是为了在发送多个请求时，解决因带宽低而导致响应变慢的问题。
压缩 HTTP 首部
压缩 HTTP 请求和响应的首部。这样一来，通信产生的数据包数量和发送的字节数就更少了。
推送功能
支持服务器主动向客户端推送数据的功能。这样，服务器可直接发送
数据，而不必等待客户端的请求。
服务器提示功能
服务器可以主动提示客户端请求所需的资源。由于在客户端发现资源之前就可以获知资源的存在，因此在资源已缓存等情况下，可以避免发送不必要的请求。&lt;/p&gt;
&lt;h3 id=&#34;923-spdy消除web瓶颈了吗&#34;&gt;9.2.3 SPDY消除Web瓶颈了吗
&lt;/h3&gt;&lt;p&gt;因为 SPDY 基本上只是将单个域名（ IP 地址）的通信多路复用，所以当一个 Web 网站上使用多个域名下的资源，改善效果就会受到限制。
SPDY 的确是一种可有效消除 HTTP 瓶颈的技术，但很多 Web 网站存在的问题并非仅仅是由 HTTP 瓶颈所导致。&lt;/p&gt;
&lt;h2 id=&#34;93-使用浏览器进行全双工通信的websocket&#34;&gt;9.3 使用浏览器进行全双工通信的WebSocket
&lt;/h2&gt;&lt;h3 id=&#34;931websocket-的设计与功能&#34;&gt;9.3.1　WebSocket 的设计与功能
&lt;/h3&gt;&lt;p&gt;WebSocket，即 Web 浏览器与 Web 服务器之间全双工通信标准。其中，WebSocket 协议由 IETF 定为标准，WebSocket API 由 W3C 定为标准。仍在开发中的 WebSocket 技术主要是为了解决 Ajax 和 Comet里 XMLHttpRequest 附带的缺陷所引起的问题。&lt;/p&gt;
&lt;h3 id=&#34;932websocket-协议&#34;&gt;9.3.2　WebSocket 协议
&lt;/h3&gt;&lt;p&gt;一旦 Web 服务器与客户端之间建立起 WebSocket 协议的通信连接，之后所有的通信都依靠这个专用协议进行。通信过程中可互相发送JSON、XML、HTML 或图片等任意格式的数据。&lt;br&gt;
WebSocket 协议的主要特点。
推送功能
支持由服务器向客户端推送数据的推送功能。这样，服务器可直接发送数据，而不必等待客户端的请求。
减少通信量
只要建立起 WebSocket 连接，就希望一直保持连接状态。和 HTTP 相比，不但每次连接时的总开销减少，而且由于 WebSocket 的首部信息很小，通信量也相应减少了。
为了实现 WebSocket 通信，在 HTTP 连接建立之后，需要完成一次“握手”（Handshaking）的步骤。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;握手·请求
为了实现 WebSocket 通信，需要用到 HTTP 的 Upgrade 首部字段，告知服务器通信协议发生改变，以达到握手的目的。&lt;/li&gt;
&lt;li&gt;握手·响应
对于之前的请求，返回状态码 101 Switching Protocols 的响应。
成功握手确立 WebSocket 连接之后，通信时不再使用 HTTP 的数据帧，而采用 WebSocket 独立的数据帧。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;94-期盼已久的http20&#34;&gt;9.4 期盼已久的HTTP/2.0
&lt;/h2&gt;&lt;p&gt;目标是改善用户在使用 Web 时的速度体验&lt;/p&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;压缩&lt;/th&gt;
          &lt;th&gt;SPDY、Friendly&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;多路复用&lt;/td&gt;
          &lt;td&gt;SPDY&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;TLS义务化&lt;/td&gt;
          &lt;td&gt;Speed＋ Mobility&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;协商&lt;/td&gt;
          &lt;td&gt;Speed＋ Mobility，Friendly&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;客户端拉曳（Client Pull）/服务器推送（Server Push）&lt;/td&gt;
          &lt;td&gt;Speed＋ Mobility&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;流量控制&lt;/td&gt;
          &lt;td&gt;SPDY&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;WebSocket&lt;/td&gt;
          &lt;td&gt;Speed＋ Mobility&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&#34;95-web-服务器管理文件的-webdav&#34;&gt;9.5 Web 服务器管理文件的 WebDAV
&lt;/h2&gt;&lt;p&gt;WebDAV（Web-based Distributed Authoring and Versioning，基于万维网的分布式创作和版本控制）是一个可对 Web 服务器上的内容直接进行文件复制、编辑等操作的分布式文件系统。&lt;br&gt;
除了创建、删除文件等基本功能，它还具备文件创建者管理、文件编辑过程中禁止其他用户内容覆盖的加锁功能，以及对文件内容修改的版本控制功能。&lt;/p&gt;
&lt;h3 id=&#34;951扩展-http11-的-webdav&#34;&gt;9.5.1　扩展 HTTP/1.1 的 WebDAV
&lt;/h3&gt;&lt;p&gt;集合（Colle ction）：是一种统一管理多个资源的概念。以集合为单位可进行各种操作。也可实现类似集合的集合这样的叠加。
资源（Re source）：把文件或集合称为资源。
属性（Prope rty）：定义资源的属性。定义以“名称 = 值”的格式执行。
锁（Lock）：把文件设置成无法编辑状态。多人同时编辑时，可防止在同一时间进行内容写入。&lt;/p&gt;
&lt;h3 id=&#34;952-webdav内新增的方法及状态码&#34;&gt;9.5.2 WebDAV内新增的方法及状态码
&lt;/h3&gt;&lt;p&gt;PROPFIND ：获取属性
PROPPATCH ：修改属性
MKCOL ：创建集合
COPY ：复制资源及属性
MOVE ：移动资源
LOCK ：资源加锁
UNLOCK ：资源解锁
为配合扩展的方法，状态码也随之扩展。
102 Proce ssing ：可正常处理请求，但目前是处理中状态
207 Multi-Status ：存在多种状态
422 Unproce ssible Entity ：格式正确，内容有误
423 Locke d ：资源已被加锁
424 Faile d De pe nde ncy ：处理与某请求关联的请求失败，因此不再维持依赖关系
507 Insufficie nt Storage ：保存空间不足&lt;/p&gt;
&lt;h1 id=&#34;10-构建web内容的技术&#34;&gt;10 构建Web内容的技术
&lt;/h1&gt;&lt;h2 id=&#34;101-html&#34;&gt;10.1 HTML
&lt;/h2&gt;&lt;h3 id=&#34;1011web-页面几乎全由-html-构建&#34;&gt;10.1.1　Web 页面几乎全由 HTML 构建
&lt;/h3&gt;&lt;p&gt;HTML（HyperText Markup Language，超文本标记语言）是为了发送Web 上的超文本（Hypertext）而开发的标记语言。超文本是一种文档系统，可将文档中任意位置的信息与其他信息（文本或图片等）建立关联，即超链接文本。标记语言是指通过在文档的某部分穿插特别的
字符串标签，用来修饰文档的语言。我们把出现在 HTML 文档内的这种特殊字符串叫做 HTML 标签（Tag）。&lt;/p&gt;
&lt;h3 id=&#34;1012-html的版本&#34;&gt;10.1.2 HTML的版本
&lt;/h3&gt;&lt;p&gt;TML5 标准不仅解决了浏览器之间的兼容性问题，并且可把文本作为数据对待，更容易复用，动画等效果也变得更生动。&lt;/p&gt;
&lt;h3 id=&#34;1013设计应用-css&#34;&gt;10.1.3　设计应用 CSS
&lt;/h3&gt;&lt;p&gt;CSS（Cascading Style Sheets，层叠样式表）可以指定如何展现 HTML内的各种元素，属于样式表标准之一。即使是相同的 HTML 文档，通过改变应用的 CSS，用浏览器看到的页面外观也会随之改变。
&lt;font color=#DC143C&gt; CSS的理念就是让文档的结构和设计分离，达到解耦的目的。&lt;/font&gt;&lt;/p&gt;
&lt;h2 id=&#34;102动态-html&#34;&gt;10.2　动态 HTML
&lt;/h2&gt;&lt;h3 id=&#34;1021让-web-页面动起来的动态-html&#34;&gt;10.2.1　让 Web 页面动起来的动态 HTML
&lt;/h3&gt;&lt;p&gt;所谓动态 HTML（Dynamic HTML），是指使用客户端脚本语言将静态的 HTML 内容变成动态的技术的总称。
动态 HTML 技术是通过调用客户端脚本语言 JavaScript，实现对HTML 的 Web 页面的动态改造。利用 DOM（Document Object Model，文档对象模型）可指定欲发生动态变化的 HTML 元素。&lt;/p&gt;
&lt;h3 id=&#34;1022更易控制-html-的-dom&#34;&gt;10.2.2　更易控制 HTML 的 DOM
&lt;/h3&gt;&lt;p&gt;DOM 是用以操作 HTML 文档和 XML 文档的 API（Application Programming Interface，应用编程接口）。使用 DOM 可以将 HTML 内的元素当作对象操作，如取出元素内的字符串、改变那个 CSS 的属性等，使页面的设计发生改变。&lt;/p&gt;
&lt;h2 id=&#34;103web-应用&#34;&gt;10.3　Web 应用
&lt;/h2&gt;&lt;h3 id=&#34;1031通过-web-提供功能的-web-应用&#34;&gt;10.3.1　通过 Web 提供功能的 Web 应用
&lt;/h3&gt;&lt;p&gt;Web 应用是指通过 Web 功能提供的应用程序。
由程序创建的内容称为动态内容，而事先准备好的内容称为静态内容。Web 应用则作用于动态内容之上。&lt;/p&gt;
&lt;h3 id=&#34;1032与-web-服务器及程序协作的-cgi&#34;&gt;10.3.2　与 Web 服务器及程序协作的 CGI
&lt;/h3&gt;&lt;p&gt;CGI（Common Gateway Interface，通用网关接口）是指 Web 服务器在接收到客户端发送过来的请求后转发给程序的一组机制。&lt;/p&gt;
&lt;h3 id=&#34;1033因-java-而普及的-servlet&#34;&gt;10.3.3　因 Java 而普及的 Servlet
&lt;/h3&gt;&lt;p&gt;Servlet1 是一种能在服务器上创建动态内容的程序。Servlet 是用 Java语言实现的一个接口。
Servlet 的运行环境叫做 Web 容器或 Servlet 容器。&lt;/p&gt;
&lt;h2 id=&#34;104数据发布的格式及语言&#34;&gt;10.4　数据发布的格式及语言
&lt;/h2&gt;&lt;h3 id=&#34;1041可扩展标记语言&#34;&gt;10.4.1　可扩展标记语言
&lt;/h3&gt;&lt;p&gt;XML（eXtensible Markup Language，可扩展标记语言）是一种可按应用目标进行扩展的通用标记语言。旨在通过使用 XML，使互联网数据共享变得更容易。&lt;/p&gt;
&lt;h3 id=&#34;1042发布更新信息的-rssatom&#34;&gt;10.4.2　发布更新信息的 RSS/Atom
&lt;/h3&gt;&lt;p&gt;RSS（简易信息聚合，也叫聚合内容）和 Atom 都是发布新闻或博客日志等更新信息文档的格式的总称。两者都用到了 XML。&lt;br&gt;
Atom标准
Atom 供稿格式（Atom Syndication Format）：为发布内容而制定的网站消息来源格式，单讲 Atom 时，就是指此标准。
Atom 出版协定（Atom Publishing Protocol）：为 Web 上内容的新增或修改而制定的议。&lt;/p&gt;
&lt;h3 id=&#34;1043javascript-衍生的轻量级易用-json&#34;&gt;10.4.3　JavaScript 衍生的轻量级易用 JSON
&lt;/h3&gt;&lt;p&gt;JSON（JavaScript Object Notation）是一种以JavaScript（ECMAScript）的对象表示法为基础的轻量级数据标记语言。能够处理的数据类型有 false/null/true/ 对象 / 数组 / 数字 / 字符串。&lt;/p&gt;
&lt;h1 id=&#34;11-web-的攻击技术&#34;&gt;11 Web 的攻击技术
&lt;/h1&gt;&lt;p&gt;互联网上的攻击大都将 Web 站点作为目标。&lt;/p&gt;
&lt;h2 id=&#34;111-针对web的攻击技术&#34;&gt;11.1 针对Web的攻击技术
&lt;/h2&gt;&lt;p&gt;应用 HTTP 协议的服务器和客户端，以及运行在服务器上的 Web 应用等资源是攻击目标。
HTTP 不具备必要的安全功能&lt;/p&gt;
&lt;h3 id=&#34;1111-在客户端即可篡改请求&#34;&gt;11.1.1 在客户端即可篡改请求
&lt;/h3&gt;&lt;p&gt;在 Web 应用中，从浏览器那接收到的 HTTP 请求的全部内容，都可以在客户端自由地变更、篡改。所以 Web 应用可能会接收到与预期数据不相同的内容。
在 HTTP 请求报文内加载攻击代码，就能发起对 Web 应用的攻击。通过 URL 查询字段或表单、HTTP 首部、Cookie 等途径把攻击代码传入，若这时 Web 应用存在安全漏洞，那内部信息就会遭到窃取，或被攻击者拿到管理权限。&lt;/p&gt;
&lt;h3 id=&#34;1112-针对web应用的攻击模式&#34;&gt;11.1.2 针对Web应用的攻击模式
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;主动攻击&lt;/li&gt;
&lt;li&gt;被动攻击&lt;/li&gt;
&lt;li&gt;以服务器为目标的主动攻击
主动攻击（active attack）是指攻击者通过直接访问 Web 应用，把攻击代码传入的攻击模式。由于该模式是直接针对服务器上的资源进行攻击，因此攻击者需要能够访问到那些资源。
&lt;img src=&#34;https://oslinss.github.io/085c58c2-cfaa-43e5-8136-6df0374ff308-1.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;alt text&#34;
	
	
&gt;&lt;/li&gt;
&lt;li&gt;以服务器为目标的被动攻击
被动攻击（passive attack）是指利用圈套策略执行攻击代码的攻击模式。在被动攻击过程中，攻击者不直接对目标 Web 应用访问发起攻击。击模式里具有代表性的攻击是 SQL 注入攻击和 OS 命令注入攻击。&lt;br&gt;
攻击模式
步骤 1： 攻击者诱使用户触发已设置好的陷阱，而陷阱会启动发送已嵌入攻击代码的 HTTP 请求。
步骤 2： 当用户不知不觉中招之后，用户的浏览器或邮件客户端就会触发这个陷阱。
步骤 3： 中招后的用户浏览器会把含有攻击代码的 HTTP 请求发送给作为攻击目标的 Web 应用，运行攻击代码。
步骤 4： 执行完攻击代码，存在安全漏洞的 Web 应用会成为攻击者的跳板，可能导致用户所持的 Cookie 等个人信息被窃取，登录状态中的用户权限遭恶意滥用等后果。
被动攻击模式中具有代表性的攻击是跨站脚本攻击和跨站点请求伪造。
&lt;img src=&#34;https://oslinss.github.io/02e4e5ad-96c3-4fd3-e3b0-719649ad448c-1.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;alt text&#34;
	
	
&gt;
利用被动攻击，可发起对原本从互联网上无法直接访问的企业内网等网络的攻击。只要用户踏入攻击者预先设好的陷阱，在用户能够访问到的网络范围内，即使是企业内网也同样会受到攻击。
&lt;img src=&#34;https://oslinss.github.io/4fbe0064-ede8-40d4-83ea-3b148550ad60-1.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;alt text&#34;
	
	
&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;112-因输出值转义不完全引发的安全漏洞&#34;&gt;11.2 因输出值转义不完全引发的安全漏洞
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;实施 Web 应用的安全对策&lt;/li&gt;
&lt;li&gt;客户端的验证
* Web 应用端（服务器端）的验证
* 输入值验证输出值转义
Web 应用端的输入值验证按 Web 应用内的处理则有可能被误认为是具有攻击性意义的代码。输入值验证通常是指检查是否是符合系统业务逻辑的数值或检查字符编码等预防对策。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;1121跨站脚本攻击&#34;&gt;11.2.1　跨站脚本攻击
&lt;/h3&gt;&lt;p&gt;跨站脚本攻击（Cross-Site Scripting，XSS）是指通过存在安全漏洞的Web 网站注册用户的浏览器内运行非法的 HTML 标签或 JavaScript 进行的一种攻击。
跨站脚本攻击可能造成影响：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;利用虚假输入表单骗取用户个人信息。&lt;/li&gt;
&lt;li&gt;利用脚本窃取用户的 Cookie 值，被害者在不知情的情况下，&lt;/li&gt;
&lt;li&gt;帮助攻击者发送恶意请求。&lt;/li&gt;
&lt;li&gt;显示伪造的文章或图片。
&lt;br&gt;
XSS 是攻击者利用预先设置的陷阱触发的被动攻击
跨站脚本攻击属于被动攻击模式，因此攻击者会事先布置好用于攻击的陷阱。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;1122sql-注入攻击&#34;&gt;11.2.2　SQL 注入攻击
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;会执行非法 SQL 的 SQL 注入攻击
SQL 注入（SQL Injection）是指针对 Web 应用使用的数据库，通过运行非法的 SQL 而产生的攻击。
SQL注入攻击可能造成影响：
非法查看或篡改数据库内的数据
规避认证
执行和数据库服务器业务关联的程序等
&lt;br&gt;
SQL 是用来操作关系型数据库管理系统（Relational DataBase Management System，RDBMS）的数据库语言，可进行操作数据或定义数据等。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;1123-os命令注入攻击&#34;&gt;11.2.3 OS命令注入攻击
&lt;/h3&gt;&lt;p&gt;OS 命令注入攻击（OS Command Injection）是指通过 Web 应用，执行非法的操作系统命令达到攻击的目的。只要在能调用 Shell 函数的地方就有存在被攻击的风险。&lt;/p&gt;
&lt;h3 id=&#34;1124-http-首部注入攻击&#34;&gt;11.2.4 HTTP 首部注入攻击
&lt;/h3&gt;&lt;p&gt;HTTP 首部注入攻击（HTTP Header Injection）是指攻击者通过在响应首部字段内插入换行，添加任意响应首部或主体的一种攻击。属于被动攻击模式。
向首部主体内添加内容的攻击称为 HTTP 响应截断攻击（HTTP Response Splitting Attack）
HTTP首部注入攻击可能造成影响：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;设置任何 Cookie 信息&lt;/li&gt;
&lt;li&gt;重定向至任意 URL&lt;/li&gt;
&lt;li&gt;显示任意的主体（HTTP 响应截断攻击）
&lt;br&gt;
HTTP 响应截断攻击
HTTP 响应截断攻击是用在 HTTP 首部注入的一种攻击。攻击顺序相同，但是要将两个 %0D%0A%0D%0A 并排插入字符串后发送。利用这两个连续的换行就可作出 HTTP 首部与主体分隔所需的空行了，这样就能显示伪造的主体，达到攻击目的。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;1125-邮件首部注入攻击&#34;&gt;11.2.5 邮件首部注入攻击
&lt;/h3&gt;&lt;p&gt;邮件首部注入（Mail Header Injection）是指 Web 应用中的邮件发送功能，攻击者通过向邮件首部 To 或 Subject 内任意添加非法内容发起的攻击。&lt;/p&gt;
&lt;h3 id=&#34;1126目录遍历攻击&#34;&gt;11.2.6　目录遍历攻击
&lt;/h3&gt;&lt;p&gt;目录遍历（Directory Traversal）攻击是指对本无意公开的文件目录，通过非法截断其目录路径后，达成访问目的的一种攻击。这种攻击有时也称为路径遍历（Path Traversal）攻击。&lt;/p&gt;
&lt;h3 id=&#34;1127-远程文件包含漏洞&#34;&gt;11.2.7 远程文件包含漏洞
&lt;/h3&gt;&lt;p&gt;远程文件包含漏洞（Remote File Inclusion）是指当部分脚本内容需要从其他文件读入时，攻击者利用指定外部服务器的 URL充当依赖文件，让脚本读取之后，就可运行任意脚本的一种攻击。&lt;/p&gt;
&lt;h2 id=&#34;113-因设置或设计上的缺陷引发的安全漏洞&#34;&gt;11.3 因设置或设计上的缺陷引发的安全漏洞
&lt;/h2&gt;&lt;h3 id=&#34;131-强制浏览&#34;&gt;1.3.1 强制浏览
&lt;/h3&gt;&lt;p&gt;强制浏览（Forced Browsing）安全漏洞是指，从安置在 Web 服务器的公开目录下的文件中，浏览那些原本非自愿公开的文件。
强制浏览可能造成的影响&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;泄露顾客的个人信息等重要情报&lt;/li&gt;
&lt;li&gt;泄露原本需要具有访问权限的用户才可查阅的信息内容&lt;/li&gt;
&lt;li&gt;泄露未外连到外界的文件&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;1132-不正确的错误消息处理&#34;&gt;11.3.2 不正确的错误消息处理
&lt;/h3&gt;&lt;p&gt;不正确的错误消息处理（Error Handling Vulnerability）的安全漏洞是指，Web 应用的错误信息内包含对攻击者有用的信息。与 Web 应用
有关的主要错误信息如下所示。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Web 应用抛出的错误消息&lt;/li&gt;
&lt;li&gt;数据库等系统抛出的错误消息
&lt;br&gt;
错误抛出的错误&lt;/li&gt;
&lt;li&gt;PHP 或 ASP 等脚本错误&lt;/li&gt;
&lt;li&gt;数据库或中间件的错误&lt;/li&gt;
&lt;li&gt;Web 服务器的错误
各系统应对详细的错误消息进行抑制设定，或使用自定义错误消息，以避免某些错误信息给攻击者以启发。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;1133-开放重定向&#34;&gt;11.3.3 开放重定向
&lt;/h3&gt;&lt;p&gt;开放重定向（Open Redirect）是一种对指定的任意 URL作重定向跳转的功能。&lt;/p&gt;
&lt;h2 id=&#34;114-因会话管理疏忽引发的安全漏洞&#34;&gt;11.4 因会话管理疏忽引发的安全漏洞
&lt;/h2&gt;&lt;h3 id=&#34;1141-会话劫持&#34;&gt;11.4.1 会话劫持
&lt;/h3&gt;&lt;p&gt;会话劫持（Session Hijack）是指攻击者通过某种手段拿到了用户的会话 ID，并非法使用此会话 ID 伪装成用户，达到攻击的目的。
可获得会话 ID 的途径。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;通过非正规的生成方法推测会话 ID&lt;/li&gt;
&lt;li&gt;通过窃听或 XSS 攻击盗取会话 ID&lt;/li&gt;
&lt;li&gt;通过会话固定攻击（Session Fixation）强行获取会话 ID&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;1142-会话固定攻击&#34;&gt;11.4.2 会话固定攻击
&lt;/h3&gt;&lt;p&gt;对以窃取目标会话 ID 为主动攻击手段的会话劫持而言，会话固定攻击（Session Fixation）攻击会强制用户使用攻击者指定的会话 ID，属于被动攻击。&lt;br&gt;
&lt;strong&gt;Session Adoption&lt;/strong&gt;
Session Adoption 是指 PHP 或 ASP.NET 能够接收处理未知会话 ID的功能。
恶意使用该功能便可跳过会话固定攻击的准备阶段，从 Web 网站 获得发行的会话 ID 的步骤。&lt;/p&gt;
&lt;h3 id=&#34;1143-跨站点请求伪造&#34;&gt;11.4.3 跨站点请求伪造
&lt;/h3&gt;&lt;p&gt;跨站点请求伪造（Cross-Site Request Forgeries，CSRF）攻击是指攻击者通过设置好的陷阱，强制对已完成认证的用户进行非预期的个人信息或设定信息等某些状态更新，属于被动攻击。
跨站点请求伪造可能造成影响&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;利用已通过认证的用户权限更新设定信息等&lt;/li&gt;
&lt;li&gt;利用已通过认证的用户权限购买商品&lt;/li&gt;
&lt;li&gt;利用已通过认证的用户权限在留言板上发表言论&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;115-其他安全漏洞&#34;&gt;11.5 其他安全漏洞
&lt;/h2&gt;&lt;h3 id=&#34;1151-密码破解&#34;&gt;11.5.1 密码破解
&lt;/h3&gt;&lt;p&gt;密码破解攻击（Password Cracking）即算出密码，突破认证。攻击不仅限于 Web 应用，还包括其他的系统（如 FTP 或 SSH 等）。&lt;br&gt;
密码破解的手段&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;通过网络的密码试错&lt;/li&gt;
&lt;li&gt;对已加密密码的破解（指攻击者入侵系统，已获得加密或散列处理的密码数据的情况）
通过网络进行密码试错
&lt;strong&gt;穷举法&lt;/strong&gt;
穷举法（Brute-force Attack，又称暴力破解法）是指对所有密钥集合构成的密钥空间（Keyspace）进行穷举。
&lt;strong&gt;字典攻击&lt;/strong&gt;
字典攻击是指利用事先收集好的候选密码（经过各种组合方式后存入字典），枚举字典中的密码，尝试通过认证的一种攻击手法。&lt;br&gt;
通过加密过的数据中导出明文的方法&lt;/li&gt;
&lt;li&gt;通过穷举法·字典攻击进行类推&lt;/li&gt;
&lt;li&gt;彩虹表&lt;/li&gt;
&lt;li&gt;拿到密钥&lt;/li&gt;
&lt;li&gt;加密算法的漏洞
通过穷举法·字典攻击进行类推
针对密码使用散列函数进行加密处理的情况，采用和穷举法或字典攻击相同的手法，尝试调用相同的散列函数加密候选密码，然后把计算出的散列值与目标散列值匹配，类推出密码。
彩虹表
彩虹表（Rainbow Table）是由明文密码及与之对应的散列值构成的一张数据库表，是一种通过事先制作庞大的彩虹表，可在穷举法 • 字典攻击等实际破解过程中缩短消耗时间的技巧。从彩虹表内搜索散列值就可以推导出对应的明文密码。
拿到密钥
使用共享密钥加密方式对密码数据进行加密处理的情况下，如果能通过某种手段拿到加密使用的密钥，也就可以对密码数据解密了。
加密算法的漏洞
考虑到加密算法本身可能存在的漏洞，利用该漏洞尝试解密也是一种可行的方法。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;1152-点击劫持&#34;&gt;11.5.2 点击劫持
&lt;/h3&gt;&lt;p&gt;点击劫持（Clickjacking）是指利用透明的按钮或链接做成陷阱，覆盖在 Web 页面之上。然后诱使用户在不知情的情况下，点击那个链接访问内容的一种攻击手段。这种行为又称为界面伪装（UIRedressing）。&lt;/p&gt;
&lt;h3 id=&#34;1153-dos-攻击&#34;&gt;11.5.3 DoS 攻击
&lt;/h3&gt;&lt;p&gt;DoS 攻击（Denial of Service attack）是一种让运行中的服务呈停止状态的攻击。有时也叫做服务停止攻击或拒绝服务攻击。DoS 攻击的对象不仅限于 Web 网站，还包括网络设备及服务器等。&lt;br&gt;
攻击方式&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;集中利用访问请求造成资源过载，资源用尽的同时，实际上服务也就呈停止状态。&lt;/li&gt;
&lt;li&gt;通过攻击安全漏洞使服务停止。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;1154-后门程序&#34;&gt;11.5.4 后门程序
&lt;/h3&gt;&lt;p&gt;后门程序（Backdoor）是指开发设置的隐藏入口，可不按正常步骤使用受限功能。利用后门程序就能够使用原本受限制的功能。&lt;br&gt;
通常的后门程序分为以下 3 种类型。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;开发阶段作为 Debug 调用的后门程序&lt;/li&gt;
&lt;li&gt;开发者为了自身利益植入的后门程序&lt;/li&gt;
&lt;li&gt;攻击者通过某种方法设置的后门程序&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
        <item>
        <title>Information</title>
        <link>https://oslinss.github.io/p/information/</link>
        <pubDate>Wed, 02 Apr 2025 10:12:53 +0800</pubDate>
        
        <guid>https://oslinss.github.io/p/information/</guid>
        <description>&lt;h3 id=&#34;作者github账号oslinss&#34;&gt;作者GitHub账号：oslinss
&lt;/h3&gt;&lt;h4 id=&#34;这是作者的第一个博客&#34;&gt;这是作者的第一个博客
&lt;/h4&gt;</description>
        </item>
        
    </channel>
</rss>
