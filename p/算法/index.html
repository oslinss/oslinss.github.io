<!DOCTYPE html>
<html lang="zh-cn" dir="ltr">
    <head><meta charset='utf-8'>
<meta name='viewport' content='width=device-width, initial-scale=1'><meta name='description' content="算法笔记 1 算法基础 1.1 二分查找 二分查找是一种算法，其输入是一个有序的元素列表，对于包含n个元素的列表。 用二分查找最多需要log2n步，而简单查找最多需要n步。\n">
<title>算法</title>

<link rel='canonical' href='https://oslinss.github.io/p/%E7%AE%97%E6%B3%95/'>

<link rel="stylesheet" href="/scss/style.min.6a692fd055deae459f2a9767f57f3855ba80cafd5041317f24f7360f6ca47cdf.css"><meta property='og:title' content="算法">
<meta property='og:description' content="算法笔记 1 算法基础 1.1 二分查找 二分查找是一种算法，其输入是一个有序的元素列表，对于包含n个元素的列表。 用二分查找最多需要log2n步，而简单查找最多需要n步。\n">
<meta property='og:url' content='https://oslinss.github.io/p/%E7%AE%97%E6%B3%95/'>
<meta property='og:site_name' content='林'>
<meta property='og:type' content='article'><meta property='article:section' content='Post' /><meta property='article:published_time' content='2025-04-06T13:38:53&#43;08:00'/><meta property='article:modified_time' content='2025-04-06T14:16:21&#43;08:00'/>
<meta name="twitter:title" content="算法">
<meta name="twitter:description" content="算法笔记 1 算法基础 1.1 二分查找 二分查找是一种算法，其输入是一个有序的元素列表，对于包含n个元素的列表。 用二分查找最多需要log2n步，而简单查找最多需要n步。\n">
    </head>
    <body class="
    article-page
    ">
    <script>
        (function() {
            const colorSchemeKey = 'StackColorScheme';
            if(!localStorage.getItem(colorSchemeKey)){
                localStorage.setItem(colorSchemeKey, "auto");
            }
        })();
    </script><script>
    (function() {
        const colorSchemeKey = 'StackColorScheme';
        const colorSchemeItem = localStorage.getItem(colorSchemeKey);
        const supportDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches === true;

        if (colorSchemeItem == 'dark' || colorSchemeItem === 'auto' && supportDarkMode) {
            

            document.documentElement.dataset.scheme = 'dark';
        } else {
            document.documentElement.dataset.scheme = 'light';
        }
    })();
</script>
<div class="container main-container flex on-phone--column extended"><aside class="sidebar left-sidebar sticky ">
    <button class="hamburger hamburger--spin" type="button" id="toggle-menu" aria-label="切换菜单">
        <span class="hamburger-box">
            <span class="hamburger-inner"></span>
        </span>
    </button>

    <header>
        
            
            <figure class="site-avatar">
                <a href="/">
                
                    
                    
                    
                        
                        <img src="/img/avatar_hu_f509edb42ecc0ebd.png" width="300"
                            height="300" class="site-logo" loading="lazy" alt="Avatar">
                    
                
                </a>
                
                    <span class="emoji">🍥</span>
                
            </figure>
            
        
        
        <div class="site-meta">
            <h1 class="site-name"><a href="/">林</a></h1>
            <h2 class="site-description">欢迎来到我的博客！</h2>
        </div>
    </header><ol class="menu-social">
            
                <li>
                    <a 
                        href='https://github.com/CaiJimmy/hugo-theme-stack'
                        target="_blank"
                        title="GitHub"
                        rel="me"
                    >
                        
                        
                            <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-brand-github" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <path d="M9 19c-4.3 1.4 -4.3 -2.5 -6 -3m12 5v-3.5c0 -1 .1 -1.4 -.5 -2c2.8 -.3 5.5 -1.4 5.5 -6a4.6 4.6 0 0 0 -1.3 -3.2a4.2 4.2 0 0 0 -.1 -3.2s-1.1 -.3 -3.5 1.3a12.3 12.3 0 0 0 -6.2 0c-2.4 -1.6 -3.5 -1.3 -3.5 -1.3a4.2 4.2 0 0 0 -.1 3.2a4.6 4.6 0 0 0 -1.3 3.2c0 4.6 2.7 5.7 5.5 6c-.6 .6 -.6 1.2 -.5 2v3.5" />
</svg>



                        
                    </a>
                </li>
            
                <li>
                    <a 
                        href='https://twitter.com'
                        target="_blank"
                        title="Twitter"
                        rel="me"
                    >
                        
                        
                            <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-brand-twitter" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <path d="M22 4.01c-1 .49 -1.98 .689 -3 .99c-1.121 -1.265 -2.783 -1.335 -4.38 -.737s-2.643 2.06 -2.62 3.737v1c-3.245 .083 -6.135 -1.395 -8 -4c0 0 -4.182 7.433 4 11c-1.872 1.247 -3.739 2.088 -6 2c3.308 1.803 6.913 2.423 10.034 1.517c3.58 -1.04 6.522 -3.723 7.651 -7.742a13.84 13.84 0 0 0 .497 -3.753c-.002 -.249 1.51 -2.772 1.818 -4.013z" />
</svg>



                        
                    </a>
                </li>
            
        </ol><ol class="menu" id="main-menu">
        
        
        <li class="menu-bottom-section">
            <ol class="menu">

                
                    <li id="dark-mode-toggle">
                        <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-toggle-left" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="8" cy="12" r="2" />
  <rect x="2" y="6" width="20" height="12" rx="6" />
</svg>



                        <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-toggle-right" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="16" cy="12" r="2" />
  <rect x="2" y="6" width="20" height="12" rx="6" />
</svg>



                        <span>暗色模式</span>
                    </li>
                
            </ol>
        </li>
    </ol>
</aside>

    <aside class="sidebar right-sidebar sticky">
        
            
                
    <section class="widget archives">
        <div class="widget-icon">
            <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-hash" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <line x1="5" y1="9" x2="19" y2="9" />
  <line x1="5" y1="15" x2="19" y2="15" />
  <line x1="11" y1="4" x2="7" y2="20" />
  <line x1="17" y1="4" x2="13" y2="20" />
</svg>



        </div>
        <h2 class="widget-title section-title">目录</h2>
        
        <div class="widget--toc">
            <nav id="TableOfContents">
  <ol>
    <li><a href="#11-二分查找">1.1 二分查找</a></li>
    <li><a href="#12-大o表示法">1.2 大O表示法</a>
      <ol>
        <li><a href="#121-算法的运行时间以不同的速度增加">1.2.1 算法的运行时间以不同的速度增加</a></li>
        <li><a href="#122-一些常见的大o的运行时间">1.2.2 一些常见的大O的运行时间</a></li>
      </ol>
    </li>
  </ol>

  <ol>
    <li><a href="#22-数组和链表">2.2 数组和链表</a></li>
    <li><a href="#23-选择排序">2.3 选择排序</a></li>
  </ol>

  <ol>
    <li><a href="#31-基线条件和递归条件">3.1 基线条件和递归条件</a></li>
    <li><a href="#32-栈">3.2 栈</a>
      <ol>
        <li><a href="#321-调用栈">3.2.1 调用栈</a></li>
        <li><a href="#322-递归调用栈">3.2.2 递归调用栈</a></li>
      </ol>
    </li>
  </ol>

  <ol>
    <li><a href="#41-分而治之">4.1 分而治之</a></li>
    <li><a href="#42-快速排序">4.2 快速排序</a></li>
    <li><a href="#43-平均情况和最糟情况">4.3 平均情况和最糟情况</a></li>
  </ol>

  <ol>
    <li><a href="#51-散列函数">5.1 散列函数</a></li>
    <li><a href="#52-应用案例">5.2 应用案例</a>
      <ol>
        <li><a href="#521-将散列表用于查找">5.2.1 将散列表用于查找</a></li>
        <li><a href="#522-防止重复">5.2.2 防止重复</a></li>
        <li><a href="#523-将散列表用作缓存">5.2.3 将散列表用作缓存</a></li>
      </ol>
    </li>
    <li><a href="#53-冲突">5.3 冲突</a></li>
    <li><a href="#54-性能">5.4 性能</a>
      <ol>
        <li><a href="#541-填装因子">5.4.1 填装因子</a></li>
        <li><a href="#542-良好的散列函数">5.4.2 良好的散列函数</a></li>
      </ol>
    </li>
  </ol>

  <ol>
    <li><a href="#61-图简介">6.1 图简介</a></li>
    <li><a href="#62-图是什么">6.2 图是什么</a></li>
    <li><a href="#63-广度优先搜索">6.3 广度优先搜索</a>
      <ol>
        <li><a href="#631-查找最短路径">6.3.1 查找最短路径</a></li>
        <li><a href="#632-队列">6.3.2 队列</a></li>
      </ol>
    </li>
    <li><a href="#64-实现图">6.4 实现图</a></li>
    <li><a href="#65-实现算法">6.5 实现算法</a></li>
    <li><a href="#66-运行时间">6.6 运行时间</a></li>
  </ol>

  <ol>
    <li><a href="#71-使用狄克斯特拉算法">7.1 使用狄克斯特拉算法</a></li>
    <li><a href="#72-术语">7.2 术语</a></li>
    <li><a href="#73-负权边">7.3 负权边</a></li>
  </ol>

  <ol>
    <li><a href="#np完全问题">NP完全问题</a></li>
  </ol>

  <ol>
    <li><a href="#最长公共子序列之解决方案">最长公共子序列之解决方案</a></li>
    <li><a href="#10-k最近邻算法">10 K最近邻算法</a>
      <ol>
        <li><a href="#1021-特征抽取">10.2.1 特征抽取</a></li>
      </ol>
    </li>
    <li><a href="#102-创建推荐系统">10.2 创建推荐系统</a>
      <ol>
        <li><a href="#1022-回归">10.2.2 回归</a></li>
      </ol>
    </li>
    <li><a href="#103-ocr">10.3 OCR</a></li>
  </ol>

  <ol>
    <li><a href="#111-树">11.1 树</a></li>
    <li><a href="#112-反向索引">11.2 反向索引</a></li>
    <li><a href="#113-傅里叶变换">11.3 傅里叶变换</a></li>
    <li><a href="#114-并行算法">11.4 并行算法</a></li>
    <li><a href="#115-mapreduce">11.5 MapReduce</a></li>
    <li><a href="#116-布隆过滤器和hyperloglog">11.6 布隆过滤器和HyperLogLog</a></li>
    <li><a href="#117-sha算法">11.7 SHA算法</a></li>
    <li><a href="#118-局部敏感的散列算法">11.8 局部敏感的散列算法</a></li>
    <li><a href="#119-diffie-hellman密钥交换">11.9 Diffie-Hellman密钥交换</a></li>
    <li><a href="#1110-线性规划">11.10 线性规划</a></li>
  </ol>
</nav>
        </div>
    </section>

            
        
    </aside>


            <main class="main full-width">
    <article class="main-article">
    <header class="article-header">

    <div class="article-details">
    

    <div class="article-title-wrapper">
        <h2 class="article-title">
            <a href="/p/%E7%AE%97%E6%B3%95/">算法</a>
        </h2>
    
        
    </div>

    
    
    
    
    <footer class="article-time">
        
            <div>
                <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-calendar-time" width="56" height="56" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <path d="M11.795 21h-6.795a2 2 0 0 1 -2 -2v-12a2 2 0 0 1 2 -2h12a2 2 0 0 1 2 2v4" />
  <circle cx="18" cy="18" r="4" />
  <path d="M15 3v4" />
  <path d="M7 3v4" />
  <path d="M3 11h16" />
  <path d="M18 16.496v1.504l1 1" />
</svg>
                <time class="article-time--published">Apr 06, 2025</time>
            </div>
        

        
            <div>
                <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="12" cy="12" r="9" />
  <polyline points="12 7 12 12 15 15" />
</svg>



                <time class="article-time--reading">
                    阅读时长: 8 分钟
                </time>
            </div>
        
    </footer>
    

    
</div>

</header>

    <section class="article-content">
    
    
    <h1 id="算法笔记">算法笔记
</h1><h1 id="1-算法基础">1 算法基础
</h1><h2 id="11-二分查找">1.1 二分查找
</h2><p>二分查找是一种算法，其输入是一个有序的元素列表，对于包含n个元素的列表。
用二分查找最多需要log2n步，而简单查找最多需要n步。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">def binary_search(list, item): 
</span></span><span class="line"><span class="cl">    low = 0 
</span></span><span class="line"><span class="cl">    high = len(list)-1 
</span></span><span class="line"><span class="cl">    while low &lt;= high:
</span></span><span class="line"><span class="cl">        mid = (low + high)
</span></span><span class="line"><span class="cl">        guess = list[mid] 
</span></span><span class="line"><span class="cl">        if guess == item:
</span></span><span class="line"><span class="cl">            return mid 
</span></span><span class="line"><span class="cl">        if guess &gt; item:
</span></span><span class="line"><span class="cl">            high = mid - 1 
</span></span><span class="line"><span class="cl">        else:
</span></span><span class="line"><span class="cl">            low = mid + 1 
</span></span><span class="line"><span class="cl">            return None 
</span></span><span class="line"><span class="cl">  
</span></span><span class="line"><span class="cl">my_list = [1, 3, 5, 7, 9] 
</span></span><span class="line"><span class="cl">  
</span></span><span class="line"><span class="cl">print(binary_search(my_list, 3)) 
</span></span><span class="line"><span class="cl">print(binary_search(my_list, -1)) 
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="12-大o表示法">1.2 大O表示法
</h2><p>大O表示法是一种特殊的表示法，指出了算法的速度有多快。</p>
<h3 id="121-算法的运行时间以不同的速度增加">1.2.1 算法的运行时间以不同的速度增加
</h3><p><img src="/b0916f3c-f78a-4107-d82d-a7c9843c4f5f-1.png"
	
	
	
	loading="lazy"
	
		alt="alt text"
	
	
>
<img src="/2bb365d3-efed-4a83-dc39-6baf00d9eee3-2-1.png"
	
	
	
	loading="lazy"
	
		alt="alt text"
	
	
></p>
<h3 id="122-一些常见的大o的运行时间">1.2.2 一些常见的大O的运行时间
</h3><p>O(log n)，也叫对数时间，这样的算法包括二分查找。
O(n)，也叫线性时间，这样的算法包括简单查找。
O(n * log n)，这样的算法包括第4章将介绍的快速排序——一种速度较快的排序算法。
O(n2)，这样的算法包括第2章将介绍的选择排序——一种速度较慢的排序算法。
O(n!)，这样的算法包括接下来将介绍的旅行商问题的解决方案——一种非常慢的算法。<br>
算法的速度指的并非时间，而是操作数的增速。
算法运行时间并不以秒为单位。
算法运行时间是从其增速的角度度量的。
算法的运行时间用大O表示法表示。O(log n)比O(n)快，当需要搜索的元素越多时，前者比后者快得越多。</p>
<h1 id="2-选择排序">2 选择排序
</h1><h1 id="21-内存的工作原理">2.1 内存的工作原理
</h1><p>需要将数据存储到内存时，你请求计算机提供存储空间，计算机给你一个存储地址。需要存储多项数据时，有两种基本方式——数组和链表。</p>
<h2 id="22-数组和链表">2.2 数组和链表
</h2><p>数组的元素都在一起。
链表的元素是分开的，其中每个元素都存储了下一个元素的地址。
数组的读取速度很快。
链表的插入和删除速度很快。
在同一个数组中，所有元素的类型都必须相同（都为int、double等）。
有两种访问方式：随机访问和顺序访问。
顺序访问意味着从第一个元素开始逐个地读取元素。链表只能顺序访问
<img src="/82e92ba1-01e9-4853-9c06-581ba3fd7bca-1.png"
	
	
	
	loading="lazy"
	
		alt="alt text"
	
	
></p>
<h2 id="23-选择排序">2.3 选择排序
</h2><p>随着排序的进行，每次需要检查的元素数在逐渐减少，最后一次需要检查的元素都只有一个。
需要的总时间为 O(n × n)，即O(n^2)。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">def findSmallest(arr): 
</span></span><span class="line"><span class="cl">    smallest = arr[0]
</span></span><span class="line"><span class="cl">    smallest_index = 0 
</span></span><span class="line"><span class="cl">    for i in range(1, len(arr)): 
</span></span><span class="line"><span class="cl">        if arr[i] &lt; smallest: 
</span></span><span class="line"><span class="cl">            smallest = arr[i] 
</span></span><span class="line"><span class="cl">            smallest_index = i 
</span></span><span class="line"><span class="cl">    return smallest_index 
</span></span><span class="line"><span class="cl">  
</span></span><span class="line"><span class="cl">def selectionSort(arr):
</span></span><span class="line"><span class="cl">    newArr = [] 
</span></span><span class="line"><span class="cl">    for i in range(len(arr)): 
</span></span><span class="line"><span class="cl">        smallest = findSmallest(arr)
</span></span><span class="line"><span class="cl">        newArr.append(arr.pop(smallest)) 
</span></span><span class="line"><span class="cl">    return newArr 
</span></span><span class="line"><span class="cl">  
</span></span><span class="line"><span class="cl">print(selectionSort([5, 3, 6, 2, 10]))
</span></span></code></pre></td></tr></table>
</div>
</div><h1 id="3-递归">3 递归
</h1><p>递归——函数调用自己</p>
<h2 id="31-基线条件和递归条件">3.1 基线条件和递归条件
</h2><p>每个递归函数都有两部分：基线条件（base case）和递归条件（recursive case）。
递归条件指的是函数调用自己，而基线条件则指的是函数不再调用自己，从而避免形成无限循环。</p>
<h2 id="32-栈">3.2 栈
</h2><p>栈有两种操作：压入和弹出。</p>
<h3 id="321-调用栈">3.2.1 调用栈
</h3><p>这个栈用于存储多个函数的变量，被称为调用栈。
所有函数调用都进入调用栈。
调用另一个函数时，当前函数暂停并处于未完成状态。该函数的所有变量的值都还在内存中。
调用栈可能很长，这将占用大量的内存。</p>
<h3 id="322-递归调用栈">3.2.2 递归调用栈
</h3><p><img src="/13cb2a0e-4cbf-4cce-8c89-daefa4d789ea-1.png"
	
	
	
	loading="lazy"
	
		alt="alt text"
	
	
>
<img src="/8e4608ae-48b7-42ca-f946-d6f5fdc04dc6-1.png"
	
	
	
	loading="lazy"
	
		alt="alt text"
	
	
>
<img src="/8a0ab4eb-1adc-4c02-ecfc-cfc56950ce81-1.png"
	
	
	
	loading="lazy"
	
		alt="alt text"
	
	
>
<img src="/5b029480-f68d-4db5-a000-55e70ff38c93-1.png"
	
	
	
	loading="lazy"
	
		alt="alt text"
	
	
>
<img src="/1397cf89-9a0a-4973-f9a0-858ba6fdb72e-1.png"
	
	
	
	loading="lazy"
	
		alt="alt text"
	
	
>
<img src="/4308e556-8bc8-4fa9-f3af-ebde46067d7f-1.png"
	
	
	
	loading="lazy"
	
		alt="alt text"
	
	
>
每个fact调用都有自己的x变量。在一个函数调用中不能访问另一个的x变量。</p>
<h1 id="4-快速排序">4 快速排序
</h1><h2 id="41-分而治之">4.1 分而治之
</h2><p>使用D&amp;C解决问题的过程包括两个步骤。
(1) 找出基线条件，这种条件必须尽可能简单。（最容易处理的情况是，一条边的长度是另一条边的整数倍。）
(2) 不断将问题分解（或者说缩小规模），直到符合基线条件。<br>
使用递归函数完成
（1）找出基线条件
（2）每次递归调用都必须离空数组更近一步</p>
<h2 id="42-快速排序">4.2 快速排序
</h2><p>快速排序也使用了D&amp;C
基线条件为数组为空或只包含一个元素。
从数组中选择一个元素，这个元素被称为基准值（pivot）。
(1) 选择基准值。
(2) 将数组分成两个子数组：小于基准值的元素和大于基准值的元素。
(3) 对这两个子数组进行快速排序。</p>
<h2 id="43-平均情况和最糟情况">4.3 平均情况和最糟情况
</h2><p>在最糟情况下，栈长为O(n)，而在最佳情况下，栈长为O(log n)。</p>
<h1 id="5-散列表无序">5 散列表(无序)
</h1><p>使用散列函数来确定元素的存储位置。
散列表的查找、插入和删除速度都非常快。
结果必须是均匀分布的，</p>
<h2 id="51-散列函数">5.1 散列函数
</h2><p>“将输入映射到数字”<br>
必须满足要求：
（1）它必须是一致的（总是将同样的输入映射到相同的索引）
（2）它应将不同的输入映射到不同的数字。
（3）散列函数知道数组有多大，只返回有效的索引。<br>
散列表：散列表由键和值组成。是一种结合使用散列函数和数组创建的数据结构。</p>
<h2 id="52-应用案例">5.2 应用案例
</h2><h3 id="521-将散列表用于查找">5.2.1 将散列表用于查找
</h3><p>提供DNS解析（将网址映射到IP地址）</p>
<h3 id="522-防止重复">5.2.2 防止重复
</h3><p>使用散列表来检查是否重复，速度非常快。</p>
<h3 id="523-将散列表用作缓存">5.2.3 将散列表用作缓存
</h3><p>缓存的数据存储在散列表中<br>
缓存的工作原理：网站将数据记住，而不再重新计算。<br>
优点：
（1）用户能够更快地看到网页
（2）需要做的工作更少</p>
<h2 id="53-冲突">5.3 冲突
</h2><p>给两个键分配的位置相同。<br>
处理冲突的方式：如果两个键映射到了同一个位置，就在这个位置存储一个链表。<br>
要避免冲突，需要有：
(1)较低的填装因子；
(2)良好的散列函数。</p>
<h2 id="54-性能">5.4 性能
</h2><p><img src="/708a4340-5af9-4ee4-9d87-26afcc179e4a-1.png"
	
	
	
	loading="lazy"
	
		alt="alt text"
	
	
></p>
<h3 id="541-填装因子">5.4.1 填装因子
</h3><p><img src="/47f89431-92f9-4bbc-b563-d27c7c2901da-1.png"
	
	
	
	loading="lazy"
	
		alt="alt text"
	
	
>
散列表使用数组来存储数据
填装因子度量的是散列表中有多少位置是空的<br>
调整长度：一旦填装因子开始增大（超过0.7），你就需要在散列表中添加位置</p>
<h3 id="542-良好的散列函数">5.4.2 良好的散列函数
</h3><p>良好的散列函数让数组中的值呈均匀分布。</p>
<h1 id="6-广度优先搜索">6 广度优先搜索
</h1><p>解决最短路径问题的算法被称为广度优先搜索。</p>
<h2 id="61-图简介">6.1 图简介
</h2><p>(1) 使用图来建立问题模型。
(2) 使用广度优先搜索解决问题。</p>
<h2 id="62-图是什么">6.2 图是什么
</h2><p>图由节点（node）和边（edge）组成。一个节点可能与众多节点直接相连，这些节点被称为邻居。</p>
<h2 id="63-广度优先搜索">6.3 广度优先搜索
</h2><p>广度优先搜索是一种用于图的查找算法，可解决问题：
第一类问题：从节点A出发，有前往节点B的路径吗？
第二类问题：从节点A出发，前往节点B的哪条路径最短？</p>
<h3 id="631-查找最短路径">6.3.1 查找最短路径
</h3><p>在广度优先搜索的执行过程中，搜索范围从起点开始逐渐向外延伸，即先检查一度关系，再检查二度关系。</p>
<h3 id="632-队列">6.3.2 队列
</h3><p>队列类似于栈，你不能随机地访问队列中的元素。
队列只支持两种操作：入队和出队。<br>
<font color=#DC143C>队列是一种先进先出的数据结构，而栈是一种后进先出的数据结构。</font></p>
<h2 id="64-实现图">6.4 实现图
</h2><p>有向图：关系是单向
无向图：没有箭头，直接相连的节点互为邻居</p>
<h2 id="65-实现算法">6.5 实现算法
</h2><p>在Python中，可使用函数deque来创建一个双端队列。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">from collections import deque  
</span></span><span class="line"><span class="cl">  
</span></span><span class="line"><span class="cl">def person_is_seller(name):  
</span></span><span class="line"><span class="cl">    return name[-1] == &#39;m&#39;  
</span></span><span class="line"><span class="cl">  
</span></span><span class="line"><span class="cl">def search_queue(start):  
</span></span><span class="line"><span class="cl">    search_queue = deque()  
</span></span><span class="line"><span class="cl">    search_queue += graph[start]    
</span></span><span class="line"><span class="cl">    while search_queue:  
</span></span><span class="line"><span class="cl">        person = search_queue.popleft()  
</span></span><span class="line"><span class="cl">        if person_is_seller(person):  
</span></span><span class="line"><span class="cl">            print(person + &#34; is a mango seller&#34;)  
</span></span><span class="line"><span class="cl">            return True  
</span></span><span class="line"><span class="cl">        else:  
</span></span><span class="line"><span class="cl">            search_queue += graph[person]  
</span></span><span class="line"><span class="cl">    return False  
</span></span><span class="line"><span class="cl">  
</span></span><span class="line"><span class="cl">graph = {}  
</span></span><span class="line"><span class="cl">graph[&#34;you&#34;] = [&#34;alice&#34;, &#34;bob&#34;, &#34;claire&#34;]  
</span></span><span class="line"><span class="cl">graph[&#34;bob&#34;] = [&#34;anuj&#34;, &#34;peggy&#34;]  
</span></span><span class="line"><span class="cl">graph[&#34;alice&#34;] = [&#34;peggy&#34;]  
</span></span><span class="line"><span class="cl">graph[&#34;claire&#34;] = [&#34;thom&#34;, &#34;jonny&#34;]  
</span></span><span class="line"><span class="cl">graph[&#34;anuj&#34;] = []  
</span></span><span class="line"><span class="cl">graph[&#34;peggy&#34;] = []  
</span></span><span class="line"><span class="cl">graph[&#34;thom&#34;] = []  
</span></span><span class="line"><span class="cl">graph[&#34;jonny&#34;] = []  
</span></span><span class="line"><span class="cl">  
</span></span><span class="line"><span class="cl">search_queue(&#34;you&#34;)
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="66-运行时间">6.6 运行时间
</h2><p>广度优先搜索的运行时间为O(人数 + 边数)，这通常写作O(V + E)，其中V为顶点（vertice）数，E为边数。</p>
<h1 id="7-狄克斯特拉算法">7 狄克斯特拉算法
</h1><h2 id="71-使用狄克斯特拉算法">7.1 使用狄克斯特拉算法
</h2><p>狄克斯特拉算法包含4个步骤。
(1) 找出“最便宜”的节点，即可在最短时间内到达的节点。
(2) 更新该节点的邻居的开销，其含义将稍后介绍。
(3) 重复这个过程，直到对图中的每个节点都这样做了。
(4) 计算最终路径。</p>
<h2 id="72-术语">7.2 术语
</h2><p>狄克斯特拉算法用于每条边都有关联数字的图，这些数字称为权重
带权重的图称为加权图
不带权重的图称为非加权图<br>
狄克斯特拉算法只适用于有向无环图</p>
<h2 id="73-负权边">7.3 负权边
</h2><p>如果有负权边，就不能使用狄克斯特拉算法。<br></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">def find_lowest_cost_node(costs):
</span></span><span class="line"><span class="cl">    lowest_cost = float(&#34;inf&#34;)
</span></span><span class="line"><span class="cl">    lowest_cost_node = None
</span></span><span class="line"><span class="cl">    for node in costs:
</span></span><span class="line"><span class="cl">        cost = costs[node]
</span></span><span class="line"><span class="cl">        if cost &lt; lowest_cost and node not in processed:
</span></span><span class="line"><span class="cl">            lowest_cost = cost
</span></span><span class="line"><span class="cl">            lowest_cost_node = node
</span></span><span class="line"><span class="cl">    return lowest_cost_node
</span></span><span class="line"><span class="cl">  
</span></span><span class="line"><span class="cl">graph={}
</span></span><span class="line"><span class="cl">graph[&#34;you&#34;]=[&#34;alice&#34;,&#34;bob&#34;,&#34;claire&#34;]
</span></span><span class="line"><span class="cl">graph[&#34;start&#34;] = {} 
</span></span><span class="line"><span class="cl">graph[&#34;start&#34;][&#34;a&#34;] = 6 
</span></span><span class="line"><span class="cl">graph[&#34;start&#34;][&#34;b&#34;] = 2    
</span></span><span class="line"><span class="cl">graph[&#34;a&#34;] = {} 
</span></span><span class="line"><span class="cl">graph[&#34;a&#34;][&#34;fin&#34;] = 1 
</span></span><span class="line"><span class="cl">graph[&#34;b&#34;] = {} 
</span></span><span class="line"><span class="cl">graph[&#34;b&#34;][&#34;a&#34;] = 3 
</span></span><span class="line"><span class="cl">graph[&#34;b&#34;][&#34;fin&#34;] = 5 
</span></span><span class="line"><span class="cl">graph[&#34;fin&#34;] = {}
</span></span><span class="line"><span class="cl">  
</span></span><span class="line"><span class="cl">infinity = float(&#34;inf&#34;) 
</span></span><span class="line"><span class="cl">costs = {} 
</span></span><span class="line"><span class="cl">costs[&#34;a&#34;] = 6 
</span></span><span class="line"><span class="cl">costs[&#34;b&#34;] = 2 
</span></span><span class="line"><span class="cl">costs[&#34;fin&#34;] = infinity
</span></span><span class="line"><span class="cl">  
</span></span><span class="line"><span class="cl">parents = {} 
</span></span><span class="line"><span class="cl">parents[&#34;a&#34;] = &#34;start&#34; 
</span></span><span class="line"><span class="cl">parents[&#34;b&#34;] = &#34;start&#34; 
</span></span><span class="line"><span class="cl">parents[&#34;fin&#34;] = None
</span></span><span class="line"><span class="cl">  
</span></span><span class="line"><span class="cl">processed = []
</span></span><span class="line"><span class="cl">  
</span></span><span class="line"><span class="cl">node=find_lowest_cost_node(costs)
</span></span><span class="line"><span class="cl">while node is not None:
</span></span><span class="line"><span class="cl">    cost=costs[node]
</span></span><span class="line"><span class="cl">    neighbors=graph[node]
</span></span><span class="line"><span class="cl">    for n in neighbors.keys():
</span></span><span class="line"><span class="cl">        new_cost=cost+neighbors[n]
</span></span><span class="line"><span class="cl">        if costs[n]&gt;new_cost:
</span></span><span class="line"><span class="cl">            costs[n]=new_cost
</span></span><span class="line"><span class="cl">            parents[n]=node
</span></span><span class="line"><span class="cl">    processed.append(node)
</span></span><span class="line"><span class="cl">    node=find_lowest_cost_node(costs)
</span></span><span class="line"><span class="cl">  
</span></span><span class="line"><span class="cl">  
</span></span><span class="line"><span class="cl">print(&#34;Costs:&#34;, costs)  
</span></span><span class="line"><span class="cl">print(&#34;Parents:&#34;, parents)  
</span></span></code></pre></td></tr></table>
</div>
</div><h1 id="8-贪婪算法">8 贪婪算法
</h1><p>优点——简单易行
每步都采取最优的做法
狄克斯特拉算法</p>
<h2 id="np完全问题">NP完全问题
</h2><p>旅行商问题和集合覆盖问题需要计算所有的解（阶乘函数），并从中选出最小/最短的那个<br>
面临NP完全问题时，最佳的做法是使用近似算法。
贪婪算法易于实现、运行速度快，是不错的近似算法。</p>
<h1 id="9-动态规划">9 动态规划
</h1><p>动态规划先解决子问题，再逐步解决大问题。
<img src="/03516fdb-75e4-42ec-c49c-852c726d37be-1.png"
	
	
	
	loading="lazy"
	
		alt="alt text"
	
	
>
<img src="/fa79b792-d201-47ba-cfa1-c0060d9e96d4-1.png"
	
	
	
	loading="lazy"
	
		alt="alt text"
	
	
>
问题可分解为离散子问题时，可使用动态规划来解决。
每种动态规划解决方案都涉及网格。
单元格中的值通常就是你要优化的值。
每个单元格都是一个子问题，因此你需要考虑如何将问题分解为子问题。</p>
<h2 id="最长公共子序列之解决方案">最长公共子序列之解决方案
</h2><p><img src="/6fcaf2fc-c80a-41a0-cf94-61fef1327c5d-1.png"
	
	
	
	loading="lazy"
	
		alt="alt text"
	
	
></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">if word_a[i] == word_b[j]:
</span></span><span class="line"><span class="cl">  cell[i][j] = cell[i-1][j-1] + 1 
</span></span><span class="line"><span class="cl">else: 
</span></span><span class="line"><span class="cl">  cell[i][j] = max(cell[i-1][j],cell[i][j-1]) 
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="10-k最近邻算法">10 K最近邻算法
</h2><p>KNN用于分类和回归，需要考虑最近的邻居。
分类就是编组。</p>
<h3 id="1021-特征抽取">10.2.1 特征抽取
</h3><p>特征抽取意味着将物品（如水果或用户）转换为一系列可比较的数字。
能否挑选合适的特征事关KNN算法的成败。</p>
<h2 id="102-创建推荐系统">10.2 创建推荐系统
</h2><h3 id="1022-回归">10.2.2 回归
</h3><p>回归就是预测结果（如数字）。</p>
<h2 id="103-ocr">10.3 OCR
</h2><p>OCR指的是光学字符识别（optical character recognition）
OCR算法提取线段、点和曲线等特征。
OCR的第一步是查看大量的数字图像并提取特征，这被称为训练（training）。</p>
<h1 id="11-算法">11 算法
</h1><h2 id="111-树">11.1 树
</h2><p>二叉查找树：对于其中的每个节点，左子节点的值都比它小，而右子节点的值都比它大。
二叉查找树的插入和删除操作的速度要快得多。</p>
<h2 id="112-反向索引">11.2 反向索引
</h2><p>一个散列表，将单词映射到包含它的页面。这种数据结构被称为反向索引（inverted index），常用于创建搜索引擎</p>
<h2 id="113-傅里叶变换">11.3 傅里叶变换
</h2><p>傅里叶变换非常适合用于处理信号，可使用它来压缩音乐。</p>
<h2 id="114-并行算法">11.4 并行算法
</h2><p>改善性能和可扩展性
并行性管理开销
负载均衡</p>
<h2 id="115-mapreduce">11.5 MapReduce
</h2><p>MapReduce是一种流行的分布式算法，你可通过流行的开源工具Apache Hadoop来使用它。<br>
原理：
映射函数：它接受一个数组，并对其中的每个元素执行同样的处理（映射是将一个数组转换为另一个数组。）
归并函数：将很多项归并为一项。（归并是将一个数组转换为一个元素。下面是一个示例。）</p>
<h2 id="116-布隆过滤器和hyperloglog">11.6 布隆过滤器和HyperLogLog
</h2><p>布隆过滤器是一种概率型数据结构
布隆过滤器的优点在于占用的存储空间很少<br>
HyperLogLog近似地计算集合中不同的元素数，而占用的内存空间却少得多。
面临海量数据且只要求答案八九不离十时，可考虑使用概率型算法！</p>
<h2 id="117-sha算法">11.7 SHA算法
</h2><p>安全散列算法函数是散列函数。给定一个字符串，SHA返回其散列值。</p>
<h2 id="118-局部敏感的散列算法">11.8 局部敏感的散列算法
</h2><p>对字符串做细微的修改，Simhash生成的散列值也只存在细微的差别</p>
<h2 id="119-diffie-hellman密钥交换">11.9 Diffie-Hellman密钥交换
</h2><p>Diffie-Hellman使用两个密钥：公钥和私钥。</p>
<h2 id="1110-线性规划">11.10 线性规划
</h2><p>线性规划用于在给定约束条件下最大限度地改善指定的指标。
线性规划使用Simplex算法</p>

</section>


    <footer class="article-footer">
    

    
    <section class="article-copyright">
        <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copyright" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="12" cy="12" r="9" />
  <path d="M14.5 9a3.5 4 0 1 0 0 6" />
</svg>



        <span>Licensed under CC BY-NC-SA 4.0</span>
    </section>
    <section class="article-lastmod">
        <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="12" cy="12" r="9" />
  <polyline points="12 7 12 12 15 15" />
</svg>



        <span>
            最后更新于 Apr 06, 2025 14:16 &#43;0800
        </span>
    </section></footer>


    
</article>

    

    

     
    
        
    <div class="disqus-container">
    <div id="disqus_thread"></div>
<script>
    window.disqus_config = function () {
    
    
    
    };
    (function() {
        if (["localhost", "127.0.0.1"].indexOf(window.location.hostname) != -1) {
            document.getElementById('disqus_thread').innerHTML = 'Disqus comments not available by default when the website is previewed locally.';
            return;
        }
        var d = document, s = d.createElement('script'); s.async = true;
        s.src = '//' + "hugo-theme-stack" + '.disqus.com/embed.js';
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="https://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
</div>

<style>
    .disqus-container {
        background-color: var(--card-background);
        border-radius: var(--card-border-radius);
        box-shadow: var(--shadow-l1);
        padding: var(--card-padding);
    }
</style>

<script>
    window.addEventListener('onColorSchemeChange', (e) => {
        if (typeof DISQUS == 'object') {
            DISQUS.reset({
                reload: true
            });
        }
    })
</script>

    

    <footer class="site-footer">
    <section class="copyright">
        &copy; 
        
        2025 lin
    </section>
    
    <section class="powerby">
        使用 <a href="https://gohugo.io/" target="_blank" rel="noopener">Hugo</a> 构建 <br />
        主题 <b><a href="https://github.com/CaiJimmy/hugo-theme-stack" target="_blank" rel="noopener" data-version="3.30.0">Stack</a></b> 由 <a href="https://jimmycai.com" target="_blank" rel="noopener">Jimmy</a> 设计
    </section>
</footer>


    
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    
    <div class="pswp__bg"></div>

    
    <div class="pswp__scroll-wrap">

        
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                
                
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div><script 
                src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js"integrity="sha256-ePwmChbbvXbsO02lbM3HoHbSHTHFAeChekF1xKJdleo="crossorigin="anonymous"
                defer
                >
            </script><script 
                src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js"integrity="sha256-UKkzOn/w1mBxRmLLGrSeyB4e1xbrp4xylgAWb3M42pU="crossorigin="anonymous"
                defer
                >
            </script><link 
                rel="stylesheet" 
                href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css"crossorigin="anonymous"
            ><link 
                rel="stylesheet" 
                href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css"crossorigin="anonymous"
            >

            </main>
        </div>
        <script 
                src="https://cdn.jsdelivr.net/npm/node-vibrant@3.1.6/dist/vibrant.min.js"integrity="sha256-awcR2jno4kI5X0zL8ex0vi2z&#43;KMkF24hUW8WePSA9HM="crossorigin="anonymous"
                
                >
            </script><script type="text/javascript" src="/ts/main.1e9a3bafd846ced4c345d084b355fb8c7bae75701c338f8a1f8a82c780137826.js" defer></script>
<script>
    (function () {
        const customFont = document.createElement('link');
        customFont.href = "https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700&display=swap";

        customFont.type = "text/css";
        customFont.rel = "stylesheet";

        document.head.appendChild(customFont);
    }());
</script>

    </body>
</html>
